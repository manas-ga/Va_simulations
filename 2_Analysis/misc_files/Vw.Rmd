---
title: "Simulations to test methods for estimating $V_w$ from evolve and resequence experiments"
author: "Jarrod Hadfield"
output: 
  html_document:
    toc: true
css: custom.css
---
  
  <script src="hideOutput.js"></script>
  
  <script type="text/javascript">
  // When the document is fully rendered...
$(document).ready(function() {
  // ...select all header elements...
  $('h1, h2, h3, h4, h5').each(function() {
    // ...and add an id to them corresponding to their 'titles'
    $(this).attr('id', $(this).html());
  });
});
</script>


```{r include=FALSE}
if(!exists("functions_only")){
  functions_only=FALSE
}

rerun_drift_covariance_sim<-TRUE

#rmarkdown::render(file.path(if(Sys.info()["nodename"]=="sce-bio-c04553"){"~/Work/Va_simulations"}else{""} , "2_Analysis/Vw.Rmd"))

```

```{r eval=!functions_only, include=FALSE}
rm(list=ls()[-which(ls()=="functions_only")])
library(MASS)
library(lme4)
library(MCMCglmm)
library(asreml)
library(reticulate)
library(pointr)

if(Sys.info()["nodename"]=="sce-bio-c04553"){  
  base_path="~/Work/Va_simulations"
  python_path="~/miniconda3/envs/msprime-env/bin/"
}else{
  print("Manas - you need to change this!")
  base_path=""
  python_path=""
}
```

The genotypes of a base-population are simulated using a combination of MSprime and SLiM and these can be obtained using the function `extract_slim_data` from Vw_sim_functions.Rmd.  An experiment can then be simulated using SLiM or under specific scenarios using the R function `sim_exp`, as documented below. The simulation consists of initiating `nrep` replicate populations from the base population after a specified number `ngen1` generations (`ngen1=0` in `sim_exp`) of random mating without selection. The allele frequencies in the first generation of each replicate are measured. A further `ngen2-ngen1` generations are then simulated where selection operates (`ngen2-ngen1=0` in `sim_exp`) after which allele frequencies are measured again. The allele frequency changes are analysed using mixed models where locus effects capture concordant selection-induced change in allele frequencies at a locus across replicates. From these analyses estimates of the additive genetic variance in fitness ($V_w$) are obtained. Various analytical methods are considered for analysing allele frequency change, either through alternate projections and/or assumptions about the between-locus covariance matrix.

## Simulate Experiment

The function `sim_exp` takes a matrix of base-population haplotypes `c_genome` with loci in columns and haplotypes in rows. The two haplotypes of an individual are found on consecutive rows (i.e. rows 1 and 2 of `c_genome` are the haplotypes of individual 1, rows 3 and 4 are the haplotypes of individual 2). Base-population individuals are cloned to form `nrep` replicate populations (i.e. `ngen1=0`). The cloned individuals in each replicate then produce `nind` offspring where the probability of individual $i$ being the parent of an offspring is proportional to either $g_i+e_i$ (`fitness_model="I"`) or $exp(g_i+e_i)$ (`fitness_model="Exp"`). $g_i$ is obtained through $g_i=\sum_jc_{ij}\alpha_j/2$ where $c_{ij}$ is the number of reference alleles present at locus $j$ in individual $i$ (from `c_genome`) and $\alpha_j$ is the average effect for fitness at that locus. A vector of $\alpha$'s is passed through the argument `alpha` together with their position, where the order of `alpha` and `position` is assumed the same as the columns of `c_genome`. If `alpha=NULL` all genotypes are assumed to have the same expected fitness. The $e$'s are sampled from a normal distribution with mean zero and variance equal to `Ve`. The genotypes of the offspring are generated from the parental genotypes assuming standard Mendelian inheritance without mutation. The per-base recombination rate is given by `r`.  The function returns a set of allele frequencies in the offspring generation (`gen2=1`) with replicates in rows and loci in columns.

```{r simulation_function}

sim_exp<-function(c_genome, nind, r, position, nrep, alpha=NULL, Ve=0, fitness_model="Exp"){

  if(ncol(c_genome)!=length(position)){stop("position should be the same length as number of columns in c_genome")}

  if(!is.null(alpha)){
    if(ncol(c_genome)!=length(alpha)){stop("alpha should be the same length as number of columns in c_genome")}
  }

  reordering<-order(position)

  c_genome<-c_genome[,reordering]
  position<-position[reordering]

  # reorder SNPs according to map position

  n0_individuals<-nrow(c_genome)/2
  n_loci<-ncol(c_genome)

  pbar<-matrix(NA, nrep, n_loci)

  if(!is.null(alpha)){
    alpha<-alpha[reordering]
    genetic_fitness<-c_genome%*%alpha/2
    genetic_fitness<-genetic_fitness[seq(1, 2*n0_individuals, 2)]+genetic_fitness[seq(2, 2*n0_individuals, 2)]
  }else{
    genetic_fitness<-rep(0, n0_individuals)
  }

  genetic_fitness<-1+genetic_fitness-mean(genetic_fitness)
  # rescale to have mean of 1 (not necessary under the exp model)  

  if(any(genetic_fitness<0)){
    warning(paste(sum(genetic_fitness<0), "genetic fitnesses negative - set to zero"))
    genetic_fitness[which(genetic_fitness<0)]<-0
  }

  for(rep in 1:nrep){

    fitness<-genetic_fitness
    if(Ve!=0){
      if(fitness_model=="Exp"){
          fitness<-fitness+rnorm(n0_individuals, 0, sqrt(Ve))
      }
      if(fitness_model=="I"){
          m<-min(fitness)
          fitness<-fitness+rgamma(n0_individuals, shape=(m^2)/Ve, scale=Ve/m)-m
          # We wish to generate random environmental variables, X, with E[X]=0,  VAR(X)=Ve and min(X) = -min(genetic_fitness) =-m  so that fitness is non-negative 

          # To do so we simulate Y from a gamma and generate X = Y-m to satisfy the constraint that X+G>0 where G is fitness based on genotype.

          # Have a=shape and s=scale then E[X] = a*s-m and VAR(X) = a*s^2

          # Since E[X]=0 then a*s = m and so VAR(X) = m*s and s=VAR(X)/m=Ve/m

          # Since a*s = m then a*Ve/m = m and so a = (m^2)/Ve
      }
    }

    if(fitness_model=="Exp"){
      fitness<-exp(fitness)
    }
      
    genomes<-matrix(0, nind, n_loci)

    for(i in 1:nind){

      for(j in 1:2){  # sample gametes from both parents

        parent<-sample(1:n0_individuals, 1, prob=fitness)
        # sample parent j of individual i

        gamete<-rep(rbinom(1, prob=0.5, size=1), n_loci)
        # sample grandparental gamete of parent j of individual i

        r_event<-reda::simEventData(rho=r, end=max(position))
        # simulate recombination events

        if(nrow(r_event)>0){
          r_event<-r_event$time[which(r_event$event==1)]
          for(k in 1:length(r_event)){
            gamete[which(position>r_event[k])]<-abs(1-gamete[which(position>r_event[k])])
          } 
        }
        # switch grandparental gamete when a recombination event happens and so grandparental gamete is a string of 0's and 1's 

        gam0<-which(gamete==0)
        # which positions does individual i inherit from grandparental gamete 0 of parent j

        if(length(gam0)!=0){     
          genomes[i,gam0]<-genomes[i,gam0]+c_genome[(parent-1)*2+1,gam0]
          # add any reference alleles inherited from grandparental gamete 0 
        }
        if(length(gam0)!=n_loci){
          if(length(gam0)!=0){
            genomes[i,-gam0]<-genomes[i,-gam0]+c_genome[(parent-1)*2+2,-gam0]
          }else{
            genomes[i,]<-genomes[i,]+c_genome[(parent-1)*2+2,]
          }  
          # add any reference alleles inherited from grandparental gamete 1
        }
      }
    }  
    pbar[rep,]<-colMeans(genomes)/2
  }  
  pbar<-pbar[,order(reordering)]
  return(pbar)
}

```

## Analysis Parameters

### Method for projecting allele frequencies onto a new vector space 

The allele frequencies can be analysed as is (`proj="N"`) or they can be projected onto a new vector space. We consider three vector spaces. In each case we consider a projection of the form ${\bf U}{\bf D}^{-p_{a}}$ where ${\bf U}$ is matrix of orthogonal vectors, ${\bf D}$ is a diagonal matrix of square-rooted eigenvalues from the eigendecomposition of some covariance matrix and $p_{a}$ is specified (`pa`).  When `proj="L"`, ${\bf U}$ and ${\bf D}$ are the eigenvectors and eigenvalues of $\tilde{\bf L}$ where $\tilde{\bf L}$ is weighted sum of the gametic and nongametic disequilbria,  ${\bf L}^{'}$ and ${\bf L}^{''}$ respectively, where ${\bf L}={\bf L}^{'}+{\bf L}^{''}$. When `proj="LoM"`, ${\bf U}$ and ${\bf D}$ are the eigenvectors and eigenvalues of $\tilde{\bf L}\circ {\bf M}$. When `proj="BLoM"` ${\bf U}={\bf U}_{\bf L}^{\top}{\bf U}_2$ where ${\bf U}_{\bf L}$ are the eigenvectors of ${\bf L}$ and ${\bf U}_2$ and ${\bf D}$ are the eigenvalues/vectors of ${\bf U}_{\bf L}^{\top}(\tilde{\bf L}\circ {\bf M}){\bf U}_{\bf L}$. `proj="BLoM"` is similar to the `proj="LoM"` projection, but is restricted to the non-zero subspace defined by ${\bf L}$. 

Rather than retain all vectors we only retain those eigenvectors whose square-rooted eigenvalues exceed `tol`.  For `proj="L"` and `proj="BLoM"` the maximum number of retained vector is equal to the number of individuals or the number of segregating sites, which ever is smaller. Since ${\bf L}\circ {\bf M}$ is typically full-rank the `proj="LoM"` projection may have substantially more retained eigenvectors but here we restrict the maximum retained to be the minimum of the number of individuals or the number of segregating sites, which ever is smaller.

These projections generate i.i.d projected allele frequency changes when the covariance of allele frequency change is proportional to  $\tilde{\bf L}^{p_{a}}$ (`proj="L"`) or $(\tilde{\bf L}\circ {\bf M})^{p_{a}}$ (`proj="LoM"` or `proj="BLoM"`) respectively. Theoretically we expect the residuals to be i.i.d when `proj="LoM"` or  `proj="BLoM"` and $p_a=1$. We also expect them to have unit variance when the environmental variance in fitness is zero since then the census and the appropriate variance effective population size are equal - note the reduction in $Ne$ caused by linked selection appears in the between-locus rather than residual term (see below). When the the environmental variance in fitness is non-zero we expect the effective population size to be smaller than the census population. If the population size remains constant then $Ne$ is smaller than $N$ by a factor $4/(2+Vo)$ where $Vo$ is variance in offspring number. This can be specified through the term `Ne_factor` and can be obtained by setting the census population size (`n`) to one in the function `predict_Ne` which also takes the variance in $e$ (`Ve`) and the `fitness_model`.

```{r predict_Ne}
predict_Ne<-function(Ve, n, fitness_model = "Exp"){

  if(fitness_model == "Exp"){
    # assuming meanlog=0
    Vo<-4*exp(Ve)-2
  }
  if(fitness_model == "I"){
    # assuming mean=1
    Vo<-4*Ve+2
  }
  Ne<-4*n/(2+Vo)
  return(Ne)
}
```

```{r analysis_parameters, eval=!functions_only} 
proj<-"BLoM"
pa<-1
Ne_factor<-predict_Ne(0,1)
```

### Distributional assumptions about the change in allele frequency across loci.

Given the allelic effects mean vector (${\boldsymbol \mu}_\alpha$) and covariance structure (${\bf V}_\alpha$) the global mean allele frequency change *due to selection*, $E[E[\Delta {\bf p}]]$, is assumed to be equal to $(\tilde{\bf L}\circ {\bf N}){\boldsymbol \mu}_\alpha$ (`Vs="LoNL"`) or $n_g\tilde{\bf L}{\boldsymbol \mu}_\alpha$ (`Vs="L"`). The (co)variance across loci in the frequency change due to selection, $VAR[E[\Delta {\bf p}]]$, is assumed to be proportional to $(\tilde{\bf L}\circ {\bf N}){\bf V}_\alpha(\tilde{\bf L}\circ {\bf N})$ (`Vs="LoNL"`) or $n_g^2\tilde{\bf L}{\bf V}_\alpha\tilde{\bf L}$ (`Vs="L"`). The mean function is restricted to the form ${\boldsymbol \mu}_\alpha=\beta_\alpha^{(0)}+\beta^{(1)}_\alpha(x_r-x_a)$ where $x_r$ is a property of the reference allele, and $x_a$ is the same property of the alternate allele. In what follows we will consider the scenario where $x_r=p$ and $x_a=q$. For the covariance structure we restrict the form to to ${\bf V}_\alpha=\sigma_\alpha^2{\bf L}^{p_{\alpha}}$. It is also possible to ignore LD when defining ${\bf L}^{p_{\alpha}}$ above using `LDalpha=FALSE`.  The function `Vw_model` fits this model to data on allele frequency changes.  $\sigma_\alpha$ is estimated and $p_{\alpha}$,  $\beta_\alpha^{(0)}$ and $\beta_\alpha^{(1)}$ can either be specified or estimated.  If `palpha` is NA then `Vw_model` will estimate it using calls to `optim`. If either the intercept (`balpha[1]`) or slope (`balpha[2]` ) are `NA` then they will be estimated.


```{r eval=!functions_only}
Vs<-"LoNL"
palpha<-NA
balpha<-c(NA, NA)
LDalpha<-FALSE
```

### Distributional assumptions about the change in *projected* allele frequency across loci.

When projected allele frequencies are analysed we need to derive the mean and covariance structure for the projected allele frequency change due to selection from how we have chosen to model the mean and covariance structure of unprojected allele frequency changes specified through $\beta_\Delta$ and $p_\Delta$. With projection we have

$$
\begin{array}{rl}
E[E[\Delta \vec{\bf p}]]=&{\bf D}^{-p_{a}}{\bf U}^{\top}E[E[\Delta {\bf p}]]\\
\end{array}
$$

and 

$$
\begin{array}{rl}
VAR[E[\Delta \vec{\bf p}]]=&{\bf D}^{-p_{a}}{\bf U}^{\top}VAR[E[\Delta {\bf p}]]{\bf U}{\bf D}^{-p_{a}}\\
\end{array}
$$


### Method used to obtain estimates (REML or MCMC)

```{r eval=!functions_only} 
method<-"REML"  
```

### Function for getting non-recombinant matrix

```{r non_recombinant_matrix_function} 

form_nR<-function(SNPs,                   # SNP positions
                  RecombRate,             # Recombination rate between adjacent sites
                  HapLength,              # Genome size
                  AtleastOneRecomb        # Should there be at least one cross-over per meiosis?
                  ){

  nsnps<-length(SNPs)
  
  message("Computing the distance matrix...")

  Dist<-as.matrix(dist(SNPs, diag=TRUE, upper=TRUE))
  # conditional on the total number of recombination events (tn) along a chromosome, the number that fall in the interval is binomial with probability equal to the relative length of the interval to the whole and number of trials equal to tn. The non-recombination fraction is then the probability that an even number of events (including zero) fall in the interval. 

  message("Computing nR...")
  
  if(AtleastOneRecomb){

    maxn<-actuar::qztpois(1-1e-5, RecombRate*HapLength)
    # maximum number of total recombination events likely to be seen
  
    nR<-matrix(0, nsnps, nsnps)

    for(nt in 0:maxn){
      # could iterate nt from 1 since Pr(0 recombination events in total)=0.
      for(ne in seq(0,maxn,2)){
         nR<-nR+dbinom(ne, prob=Dist/HapLength, size=nt)*actuar::dztpois(nt, RecombRate*HapLength)
         # Pr(even number of crossovers falling between snps given nt)*Pr(nt recombination events in total) then sum over nt
      }
    }
    nR<-nR/actuar::pztpois(maxn, RecombRate*HapLength)
    # rescale so diag(R)=1
  
  }else{

    nR<-1 - 0.5*(1 - exp(-2*Dist*RecombRate))
  }

  return(nR)

}

```

### Function for model fitting


```{r analysis_function}


fit.model<-function(palpha, balpha, LDalpha, nsnps, UL, DL, L, ngen2, ngen1, nind, tprojp, pbar0, pbar1, pbar2, nrep, Selec, LLonly=FALSE, method = "REML", verbose=TRUE){
  
  if(verbose){
    message("Computing the covariance structure of locus effects...")
    message("Computing covp over 1 generation...")
  }

  if(LDalpha){
    if(palpha==0){
      covp<-diag(nsnps)
    }else{
      covp<-UL%*%diag(DL^(2*palpha))%*%t(UL)
    }  
  }else{
    covp<-diag(L)^palpha
  }

  rm(list = c("UL", "DL"))
  gc(verbose = FALSE)
  pmq<-2*pbar0-1

  pmq<-Selec%*%pmq
  int<-Selec%*%rep(1, nsnps)

  if(verbose){
    message("Computing SC...")
  }

  projpSelec<-t(tprojp)%*%Selec

  rm("Selec")
  gc(verbose = FALSE)

  if(LDalpha){
    SC<-projpSelec%*%covp

    rm("covp")
    gc(verbose = FALSE)

    SC<-SC%*%t(projpSelec)
    # computing COV(\Delta p_m, \Delta p_n) on the projected scale.
  }else{
    SC<-projpSelec%*%(t(projpSelec)*covp)
    # if LDalpha=F, covp is diagonal and this is more efficient. 
  }

  attr(SC, "INVERSE")<-FALSE
  dimnames(SC) <- list(1:nrow(SC),1:nrow(SC))  # used for full-form matrices
  
  if(verbose){
    message("Projecting allele frequencies...")
  }

  pbar1_proj<-pbar1%*%tprojp
  pbar2_proj<-pbar2%*%tprojp
  pmq_proj<-t(matrix(pmq, nsnps,nrep))%*%tprojp
  int_proj<-t(matrix(int, nsnps,nrep))%*%tprojp

  dat.gaussian<-data.frame(delta=c(pbar2_proj-pbar1_proj), locus=gl(ncol(pbar1_proj),nrep,ncol(pbar1_proj)*nrep), rep=gl(nrep,1,ncol(pbar1_proj)*nrep), pmq=c(pmq_proj), int=c(int_proj))


  if(!is.na(balpha[1])){
     dat.gaussian$int<-dat.gaussian$int*balpha[1]
  }
  if(!is.na(balpha[2])){
     dat.gaussian$pmq<-dat.gaussian$pmq*balpha[2]
  }

  ##############
  # Fit models #
  ##############
  
  if(verbose){
    message("Fitting linear mixed model...")
  }

  prior<-list(R=list(V=1, nu=0), G=list(G1=list(V=1, nu=1, alpha.mu=0, alpha.V=1000)))
  
  SC[lower.tri(SC)]<-t(SC)[lower.tri(SC)]
  # force symmetry in case it is not exactly symmetric

  if(method=="REML"){
    if(is.na(balpha[1]) & is.na(balpha[2])){
        m1<-asreml(delta~int+pmq-1, random = ~vm(locus, SC, singG="PSD"), data=dat.gaussian, Cfixed=TRUE)
    }
    if(is.na(balpha[1]) & !is.na(balpha[2])){
        m1<-asreml(delta~int+offset(pmq)-1, random = ~vm(locus, SC, singG="PSD"), data=dat.gaussian, Cfixed=TRUE)
    }
    if(!is.na(balpha[1]) & is.na(balpha[2])){
        m1<-asreml(delta~offset(int)+pmq-1, random = ~vm(locus, SC, singG="PSD"), data=dat.gaussian, Cfixed=TRUE)
    }
    if(!is.na(balpha[1]) & !is.na(balpha[2])){
      warning("asreml doesn't allow models without fixed effects, so intercept fitted but replaced with balpha[1]!")
      m1<-asreml(delta~offset(pmq + int), random = ~vm(locus, SC, singG="PSD"), data=dat.gaussian, Cfixed=TRUE)
    } 
  }

  if(method=="MCMC"){

    if(LLonly){stop("method = MCMC specified so can't return log-likelihood with LLony=TRUE")}

    invSC<-solve(SC)
    invSC <- as(invSC, "sparseMatrix") 
    attr(invSC, "rowNames") <- 1:retain
    attr(invSC, "colNames") <- 1:retain

    prior<-list(B=list(mu=balpha, V=diag(2)*1e+10))
    diag(prior$B$V)[which(!is.na(balpha))]<-1e-10
    prior$B$mu[which(is.na(balpha))]<-0

    m1<-MCMCglmm(delta~pmq+int-1, random=~locus, data=dat.gaussian, ginverse=list(locus=invSC), family="gaussian", pr=TRUE, prior=prior)
  }
  
  if(LLonly){
    return(m1$loglik)
  }else{
    return(list(data=dat.gaussian, model=m1, SC=SC, palpha=palpha))
  }
}



Vw_model<-function(c_genome,    # gamete genotypes (rows gametes (rows 1 & 2 individual 1, rows 3 & 4 individual 2 ...., columns loci) 
                   nR,          # matrix of non-recombinant probabilities between loci
                   pbar0,       # vector of allele frequencies at time-point 0
                   pbar1,       # vector of allele frequencies at time-point 1
                   ngen1=1,     # number of generations between parents and time-point 1
                   pbar2,       # vector of allele frequencies at time-point 2
                   ngen2,       # number of generations between parents and time-point 2
                   nind,        # population size in each replicate
                   proj,        # projection type for allele frequencies: "LoM", "BLoM", "L" or "N"
                   LDalpha,
                   pa,
                   palpha,
                   balpha,
                   Vs,
                   method,
                   L,           # between individual covariance in allele proportion
                   Ltilde,      # between gamete covariance in half allele proportion
                   svdL=NULL,   # list with elements UL and DL,
                   Ne_factor=1, # Can be a scalar or a vector (if a vector must be of length ngen2 - ngen1)
                   tol=sqrt(.Machine$double.eps),
                   save_tprojp=FALSE, 
                   verbose=TRUE)
  {
  
  asreml.options(Cfixed = TRUE)

  if(is.null(L) | is.null(Ltilde) | (is.null(svdL) & (proj=="BLoM" | LDalpha))){

    if(is.null(c_genome)){
      stop("c_genome is required if L, Ltilde or svdL are NULL")
    }

    n0_individuals<-nrow(c_genome)/2

    if(is.null(L) | (is.null(svdL) & (proj=="BLoM" | LDalpha))){

      paternal<-seq(1, 2*n0_individuals, 2)
      maternal<-paternal+1

      c0<-(c_genome[paternal,]+c_genome[maternal,])/2

      if(is.null(L)){ 
        if(verbose){
          message("Computing L in the parents' generation...")
        }
        L<-cov(c0)*(n0_individuals-1)/n0_individuals
      }  
    }

    if(is.null(Ltilde)){
      Lgp<-(cov(c_genome[paternal,])+cov(c_genome[maternal,]))*(n0_individuals-1)/(4*n0_individuals) 
      Ltilde<-Lgp+(1-nR)*(L-Lgp)/nR
      rm("Lgp")
    }
  }



  if(!proj%in%c("LoM", "BLoM", "L", "N")){stop("proj must be one of 'LoM', 'L', 'N'")}
  if(!Vs%in%c("LoNL", "L")){stop("Vs must be either 'LoNL' or 'L'")}
  if(!method%in%c("REML", "MCMC")){stop("method must be either 'REML' or 'MCMC'")}

  #################################
  # calculate projection matrices #
  #################################
  nsnps<-ncol(pbar1)
  nrep<-nrow(pbar1)

  if(ncol(pbar1)!=nsnps){stop("pbar1 should have as many columns as the number of columns in Co (the number of SNPs)")}
  if(ncol(pbar2)!=nsnps){stop("pbar2 should have as many columns as the number of columns in Co (the number of SNPs)")}

  if(nrow(pbar1)!=nrow(pbar2)){stop("pbar1 and pbar2 should have the same number of rows (the number of replicates)")}

  if(proj=="BLoM" | LDalpha){  # singular vectors of L required 

     if(is.null(svdL)){

       if(verbose){
         message("Performing SVD on C0...")
       }
       
       c0=scale(sqrt(1/nind)*c0, scale=FALSE)
        
       svdC<-svd(c0, nu = 0)
       retain<-sum(svdC$d>tol)
       UL<-svdC$v[,1:retain]
       DL<-svdC$d[1:retain]
       rm("svdC")
       gc(verbose = FALSE)
          
     }else{
        UL<-svdL$UL
        DL<-svdL$DL
        rm("svdL")
        gc(verbose = FALSE)
        retain<-ncol(UL)
     }
  }

  if(proj=="LoM" | proj=="BLoM"){ 
    
     # First decide if Ne_factor is a scalar or a vector
    
     if(length(Ne_factor) == 1){constant_Ne = TRUE}else{
       constant_Ne = FALSE
       if(length(Ne_factor)!=(ngen2 - ngen1)){stop("The length of Ne_factor must be equal to ngen2 - ngen1. Alternatively, provide a constant scalar to be used across all generations.")}
     }
    
     if(verbose){
       message("Computing M...")
     }
    
     # Calculate the summation in two steps to save memory: (1) Write down the first term, (2) add the remaining terms only if ngen2 - ngen1 >1  Note this works even if ngen1=0, at least when Ne is constant.
    
     count = 1 # a variable that references the correct element of Ne_factor

     M = ((1-1/(2*nind*Ne_factor[count]))^(ngen1))*(1/(nind*Ne_factor[count]))*nR^(1+ngen1)
     
     # Only perform further summations if (ngen2-ngen1 > 1)
     
     if((ngen2 - ngen1) > 1){
       for (x in (ngen1 + 2):(ngen2)){
        # Increase count by one only if length(Ne_factor>1) 
        if(!constant_Ne){count = count + 1}
        M = M + ((1-1/(2*nind*Ne_factor[count]))^(x-1))*(1/(nind*Ne_factor[count]))*nR^x
      }       
     }

     Drift<-Ltilde*M
     rm("M")
     # Garbage collection
     gc(verbose = FALSE)
   }

   if(Vs=="LoNL"){ 

     if(verbose){
       message("Computing N...")
     }

     # Calculate the summation in two steps to save memory: (1) Write down the first term, (2) add the remaining terms only if ngen2 - ngen1 >1
     
     count = 1

     if(ngen1!=0){  
       N = {((1-1/(2*nind*Ne_factor[count]))^(ngen1))*nR^(ngen1)}
     }else{
       if(ngen2>1){
         N = matrix(0, ncol(nR), ncol(nR))
       }
     }

     # Only perform further summations if (ngen2-ngen1 > 1)
     
     if((ngen2 - ngen1) > 1){
     
       for (x in (ngen1 + 2):(ngen2)){
         if(!constant_Ne){count = count + 1}
         N = N + {((1-1/(2*nind*Ne_factor[count]))^(x-1))*nR^(x-1)}
       }

     }
    
     if(ngen1==0){
       Selec<-L
       if(ngen2>1){
         Selec<-Selec+Ltilde*N
         rm("N")
         gc(verbose = FALSE)   
       }
     }else{
       Selec<-Ltilde*N
       rm("N")
       gc(verbose = FALSE)   
     }

   }else{
    Selec<-L*(ngen2-ngen1)
   }  

  if(proj=="LoM"){

    if(verbose){
      message("Performing eigendecomposition of L*M...")
    }

    sdLoM<-RSpectra::eigs(Drift, min(nind, nsnps))
    retain<-sum(sqrt(sdLoM$values)>tol)
    U<-sdLoM$vectors[,1:retain]
    D<-sqrt(sdLoM$values[1:retain])
    rm("sdLoM")
    # Garbage collection
    gc(verbose = FALSE)
  }

  if(proj=="BLoM"){ 

    if(verbose){
      message("Performing eigendecomposition of t(U)%*%(L*M)%*%U...")
    }

    sdLoM<-RSpectra::eigs(t(UL)%*%Drift%*%UL, retain)
    retain<-sum(sqrt(sdLoM$values)>tol)
    U<-UL%*%sdLoM$vectors[,1:retain]
    D<-sqrt(sdLoM$values[1:retain])
    rm("sdLoM")
    # Garbage collection
    gc(verbose = FALSE)
            
  }   

  if(verbose){
    message("Computing the projection matrix...")
  }

  if(proj=="N"){
    
    tprojp<-diag(nrow(pbar1))

  }else{

    tprojp<-U%*%diag(D^(-pa))

  }
  
  rm(list = c("U", "D"))
  # Garbage collection
  gc(verbose = FALSE)
  
  

  if(is.na(palpha)){

    if(verbose){
      message("Estimating palpha...")
    }

    palpha<-optim(0, fit.model, balpha=balpha, LDalpha = LDalpha, nsnps=nsnps, UL=UL, DL=DL, L=L, ngen2=ngen2, ngen1=ngen1, nind=nind, tprojp=tprojp, pbar0=pbar0, pbar1=pbar1, pbar2=pbar2, nrep=nrep, LLonly=TRUE, Selec=Selec, verbose=verbose, method = "L-BFGS-B", lower = -2, upper =2, control = list(fnscale=-1, factr = 1e+11), hessian=TRUE)

    palpha_var<--1/palpha$hessian
    palpha<-palpha$par

  }else{
    palpha_var<-0
  }

  if(verbose){
    message("Fitting the final model...")
  }

  output<-fit.model(palpha=palpha, balpha=balpha, LDalpha = LDalpha, nsnps=nsnps, UL=UL, DL=DL, L=L, ngen2=ngen2, ngen1=ngen1, nind=nind, tprojp=tprojp, pbar0=pbar0, pbar1=pbar1, pbar2=pbar2, nrep=nrep, LLonly=FALSE, Selec=Selec, verbose=verbose)

  if(verbose){
    message("Calculating the estimate of Vw...")
  }

  if(method=="REML"){
    
    sigma2alpha<-summary(output$model)$varcomp[1,1]
    S<-matrix(0,2,2)

    if(is.na(balpha[1]) & is.na(balpha[2])){
        balpha<-summary(output$model, coef=TRUE)$coef.fixed[c("int", "pmq"),1]
        S<-output$model$Cfixed[c("int", "pmq"),c("int", "pmq")]
    }
    if(is.na(balpha[1]) & !is.na(balpha[2])){
       balpha[1]<-summary(output$model, coef=TRUE)$coef.fixed["int",1]
       S["int","int"]<-output$model$Cfixed
    }
    if(!is.na(balpha[1]) & is.na(balpha[2])){
        balpha[2]<-summary(output$model, coef=TRUE)$coef.fixed["pmq",1]
        S["pmq","pmq"]<-output$model$Cfixed
    }
  }
  if(method=="MCMC"){
    sigma2alpha<-posterior.mode(output$model$VCV[,1])
    balpha<-colMeans(output$model$Sol[,c("int", "pmq")])
  }

  X<-cbind(rep(1, length(pbar0)), 2*pbar0-1)

  if(LDalpha){
    TrV<-sum(DL^(2*(output$palpha+1)))*sigma2alpha
    aLa<-t(X%*%balpha)%*%L%*%X%*%balpha-sum(diag(t(X)%*%L%*%X%*%S))
  }else{
    TrV<-sum(diag(L)^(output$palpha+1))*sigma2alpha
    aLa<-t(X%*%balpha)%*%L%*%X%*%balpha-sum(diag(t(X)%*%L%*%X%*%S))
  }

  Vw_est<-TrV+aLa

  return(list(Vw_est=Vw_est, data=output$data, model=output$model, SC=output$SC, palpha=output$palpha, balpha=balpha, palpha_var=palpha_var, balpha_var=S, tprojp=if(save_tprojp){tprojp}else{NULL}, S=S, X=X, DL=ifelse(exists("DL"), DL, NA)))

}
```

### Function for estimating the alpha distribution from actual values

We initially considered a simple model where the expected $\alpha$ depends linearly on $p-q$ with intercept $\beta^{(0)}_{\alpha}$ and slope $\beta^{(1)}_{\alpha}$. The variance is assumed to be proportional to $(pq)^{p_\alpha}$ with $p_\alpha$ also estimated. However, after visually examining how well this model fits the joint distribution of $p$ and $\alpha$ obtained from simulations, we considered an alternative three-parameter model. In this model we rescale $\pm(p-q)^{\beta^{(0)}_{\alpha}}$ to lie between 0 and 1 (by adding 1 and dividing by 2), logit transform it, and then fit it as a predictor with estimated slope, $\beta^{(1)}_{\alpha}$ (the intercept, the expected value when $p=q$, is fixed at zero). The function `pmq_trans` computes the predictor for this second model given $p-q$ (`pmq`) and $\beta^{(0)}_{\alpha}$ (`balpha_0`). As in the first model the variance is assumed to be proportional to $(pq)^{p_\alpha}$ with $p_\alpha$ also estimated. 

```{r pmq_trans}
logit<-function(x){
  log(x)-log1p(-x)
}

pmq_trans<-function(pmq, balpha_0){
  x<-sign(pmq)*abs(pmq)^balpha_0
  logit((x+1)/2)
}



```

Increasing the value of $\beta^{(0)}_{\alpha}$ causes the expected $\alpha$ to approach zero faster as it becomes less rare:

```{r pmq_trans_plot}
pmq<-seq(-1+1/1000, 1-1/1000, length=100)
plot(pmq_trans(pmq, 1)~pmq, type="l", col=hcl.colors(20, alpha=1)[1])
for(i in 2:20){
  lines(pmq_trans(pmq, i)~pmq, col=hcl.colors(20, alpha=1)[i])
}
```

Given a set of $\alpha$'s and allele frequencies $p$ the function `alpha_distribution` estimates  $\beta^{(0)}_{\alpha}$,  $\beta^{(1)}_{\alpha}$ and $p_\alpha$ for the original model (`logit=FALSE`) or the second model (`logit=TRUE`). An optional transposed projection matrix (`tprojp`) can also be given which transforms the allele frequencies and $\alpha$'s prior to model fitting. 


```{r alpha_distribution}
alpha_distribution<-function(alpha, p, tprojp=NULL, logit=FALSE, save_model=FALSE){

  pmq<-2*p-1
  pq<-p*(1-p)/2

  palpha_fit<-function(palpha, alpha, pmq, pq, tprojp){

       if(!is.null(tprojp)){
          alpha<-t(alpha%*%tprojp)
          pmq<-t(pmq%*%tprojp)
          pq<-diag(t(tprojp)%*%(tprojp*pq^palpha))
       }else{
          pq<-pq^palpha
       }

       -logLik(lm(alpha~pmq, weights=1/pq))
  }

  logit_fit<-function(par, alpha, pmq, pq,  tprojp){

        balpha_0<-par[1]
        palpha<-par[2]

        pmq<-pmq_trans(pmq, balpha_0)

        if(!is.null(tprojp)){
          alpha<-t(alpha%*%tprojp)
          pmq<-t(pmq%*%tprojp)
          pq<-diag(t(tprojp)%*%(tprojp*pq^palpha))
        }else{
          pq<-pq^palpha
        }
        -logLik(lm(alpha~pmq-1, weights=1/pq))
  }

  if(logit){
    palpha<-optim(c(1, 1), logit_fit, alpha=alpha, pmq=pmq, pq=pq, tprojp=tprojp)$par

    balpha_0<-palpha[1]
    palpha<-palpha[2]
  
    pmq<-pmq_trans(pmq, balpha_0)

    if(!is.null(tprojp)){
      alpha<-t(alpha%*%tprojp)
      pmq<-t(pmq%*%tprojp)
      pq<-diag(t(tprojp)%*%(tprojp*pq^palpha))
    }else{
      pq<-pq^palpha
    }

    m1<-lm(alpha~pmq-1, weights=1/pq)
  }else{
    palpha<-optim(0, palpha_fit, alpha=alpha, pmq=pmq, pq=pq, tprojp=tprojp, method="Brent", lower=-5, upper=5)$par

    if(!is.null(tprojp)){
      alpha<-t(alpha%*%tprojp)
      pmq<-t(pmq%*%tprojp)
      pq<-diag(t(tprojp)%*%(tprojp*pq^palpha))
    }else{
      pq<-pq^palpha
    }

    m1<-lm(alpha~pmq, weights=1/pq)
  }  

  
  result<-list(palpha=palpha, 
               balpha_0=if(logit){balpha_0}else{coef(m1)["(Intercept)"]}, 
               balpha_1=coef(m1)["pmq"],
               sigma2alpha=summary(m1)$sigma^2,
               logit=logit,
               model=if(save_model){m1}else{NULL},
               X=model.matrix(m1),
               S=summary(m1)$cov.unscaled*summary(m1)$sigma^2)

  return(result)
}
```

The function `plot_alpha_distribution` plots the $\alpha$'s against $p-q$ and overlays the expected $\alpha$ and its upper/lower 2.5\% quantiles given the parameters of a model fit. The argument `parameters` must be a list containing elements, `palpha`, `balpha_0`, `balpha_1`, `sigma2alpha` and logit. The output from `alpha_distribution` can be passed directly to the argument `parameters`. 

```{r plot_alpha_distribution}
plot_alpha_distribution<-function(alpha=NULL, p=NULL, tprojp=NULL, parameters, ...){

  pmq<-2*p-1
  pq<-p*(1-p)/2

  if(parameters$logit){
    pred<-pmq_trans(pmq, parameters$balpha_0)
    intercept<-0
  }else{
    pred<-pmq
    intercept<-parameters$balpha_0
  }
  slope<-parameters$balpha_1

  palpha<-parameters$palpha
  var<-pq^palpha

  if(is.null(tprojp)){

    pmq.x<-seq(min(pmq),max(pmq), length=1000)
    pq.x = (pmq.x+1)*(1-pmq.x)/8
    sd.x<-parameters$sigma2alpha*sqrt(pq.x^palpha)

    plot(alpha~pmq, ylab="alpha", xlab="p-q", ...)

    if(parameters$logit){
      pred.x<-pmq_trans(pmq.x, parameters$balpha_0)
    }else{
      pred.x<-pmq.x
    } 

    m.x<-intercept+slope*pred.x
    u.x<-qnorm(0.975, intercept+slope*pred.x, sd.x)
    l.x<-qnorm(0.025, intercept+slope*pred.x, sd.x)

    lines(m.x~pmq.x, col="red")
    lines(u.x~pmq.x, col="red", lty=2)
    lines(l.x~pmq.x, col="red", lty=2)
  
  }else{  

    alpha<-t(alpha%*%tprojp)
    pred<-t(pred%*%tprojp)
    var<-diag(t(tprojp)%*%(tprojp*pq^palpha))

    plot(alpha~pred, ylab="projected alpha", xlab="projected predictor", ...)

    pred.x<-seq(min(pred),max(pred), length=1000)

    m.x<-intercept+slope*pred.x
    lines(m.x~pred.x, col="red")

  }
}  
```

We can check to make sure everything is as expected

```{r eval=!functions_only} 
n<-1000

p<-runif(n)

balpha_int<-0
balpha_slope<-0.2
palpha<--1
sigma2alpha<-0.1

mu<-balpha_int+balpha_slope*(2*p-1)
v<-sigma2alpha*(p*(1-p)/2)^palpha

alpha<-rnorm(n, mu, sqrt(v))

parameters<-alpha_distribution(alpha, p)
parameters[1:4]

plot_alpha_distribution(alpha, p, parameters=parameters)
```

## Drift covariance

In the MS we drive the drift covariance in allele frequency between generation $t$ and $t+1$ as the expected gametic-phase LD in generation $t+1$ given the gametic and non-gametic phase LD in generation $t$, scaled by $1/N_e$. Here we check whether these results hold for a 2-locus model. The function `summaryG` takes a 2-column matrix of haplotypes with elements equal to 1 (AB), 2 (Ab), 3 (aB) or 4 (ab). Each row corresponds to an individual with the two columns representing the maternal or paternal gamete contribution.  The allele frequencies (`pA` and `pB`), $L^{'}$ (`Lgp`) and $L^{''}$ (`Lngp`) are returned.

```{r summaryG}
summaryG<-function(x){

  if(ncol(x)!=2 | any(!x%in%c(1:4))){
    stop("x should be an nx2 matrix with integers 1:4 corresponding to haplotypes AB (1), Ab (2), aB (3) and ab (4)")
  }

  n_hap<-length(x)

  pA<-sum(x==1 | x==2)/n_hap
  pB<-sum(x==1 | x==3)/n_hap
  # frequency of A and B alleles

  Lgp<-sum(x==1)/n_hap
  # frequency of AB haplotype

  Lgp<-Lgp-pA*pB
  # gametic phase LD

  Lngp<-sum((x[,1]==1 | x[,1]==2) & (x[,2]==1 | x[,2]==3))
  # number of individuals whose first haplotype contains an A and the second a B
  Lngp<-Lngp+sum((x[,2]==1 | x[,2]==2) & (x[,1]==1 | x[,1]==3))
  # add number of individuals whose first haplotype contains a B and the second an A
  Lngp<-Lngp/n_hap
  # frequency of individuals with A and B alleles on different haplotypes

  Lngp<-Lngp-pA*pB
  # non-gametic phase LD
 
  return(list(pA=pA, pB=pB, Lgp=Lgp, Lngp=Lngp))
}
```
The function `sample_gamete` takes a pair of haplotypes through the argument `xi` and the recombination probability between the two loci `r` and samples a gametic halpotype. 

```{r sample_gamete}
sample_gamete<-function(xi, r){
   
   r_event<-rbinom(1, size=1, prob=r)

   if(r_event & all(c(1,4)%in%xi)){xi<-c(2,3)}
   if(r_event & all(c(2,3)%in%xi)){xi<-c(1,4)}

   h_event<-rbinom(1, size=1, prob=1/2)+1

   return(xi[h_event])
}
```

In order to calculate $Ne$ we need to know the variance in offspring number in the presence of environmental variance in fitness only.  When `fitness_model="Exp"`, parents are sampled from a multinomial of length $n$ and their non-normalised probabilities, $P$, are drawn from a log-normal with `meanlog`$=0$ and `sdlog`$=x$. The expected number of offspring for parent $i$ is $Np_i$ where $p_i$ is the normalised probability for individual $i$ and $N$ the total number of offspring to be drawn.  The variance in the number offspring for parent $i$ is $Np_i(1-p_i)$ and so from the law of total variance $Var(o) = (N^2)Var(p)+NE[p(1-p)]$.  Since $E[p(1-p)]=E[p]-E[p^2]$ and $Var(p)=E[p^2]-E[p]^2$ then $E[p(1-p)]=E[p]-Var(p)+E[p]^2$. Since $E[p] = 1/n$ by definition, 


$$
\begin{array}{rl}
Var(o) =& N^2Var(p)+NE[p(1-p)]\\
       =& N^2Var(p)+\frac{N}{n}-NVar(p)+\frac{N}{n^2}\\
       =& (N^2-N)Var(p)+\frac{N}{n}+\frac{N}{n^2}\\
\end{array}
$$

which simplifies to

$$Var(o) = N^2Var(p)+N/n$$

when $N$ and $n$ are large. From the properties of the log-normal (with `meanlog`=0) we know $E[P] = exp(x^2/2)$ and $Var(P) = exp(x^2)-1)exp(x^2)$. Since $p = P/(nE[P])$

$$
\begin{array}{rl}
Var(p) =& (exp(x^2)-1)exp(x^2)/(nexp((x^2)/2))^2\\
       =& (exp(x^2)-1)exp(x^2)/(exp(x^2)*n^2)\\
       =& (exp(x^2)-1)/n^2\\
\end{array}
$$

such that 

$$Var(o) = (N^2/n^2)(exp(x^2)-1)+N/n$$

If the population size is constant then $N=2n$ this simplifies to $Var(o) = 4exp(x^2)-2$ and so $x=\sqrt(log((Var(o)+2)/4)$.  When `fitness_model="I"` the $P$ are drawn from a distribution with a mean of 1 and standard deviation $\sigma$. Under the same conditions as above $Var(o) = 4\sigma^2+2$ and so $\sigma = \sqrt{(Var(o)+2)/4}$. The variance effective population size, $Ne$ is $4n/(2+Var(o))$. We can check the derivation:       


```{r test_Vo, eval=!functions_only}

  n<-100000
  N<-2*n

  Vo<-5.2
  x<-sqrt(log((Vo+2)/4))

  (N^2-N)*(exp(x^2)-1)/n^2+N/n+N/n^2 # exact Vo 

  P<-rlnorm(n, 0, x)

  p<-P/(n*mean(P))

  var(rmultinom(1,prob=p, size=N))

```

Using the above results and functions we can simulate a pure drift scenario and look at the drift covariance. 

```{r drift_covariance_sim, eval=!functions_only}

nsim<-10000  # number of replicates
n<-100       # census population size (assumed constant)
r<-0.01      # recombination rate
Vo<-2.6      # variance in offspring number

hap.freq<-c(0.3, 0.2, 0.2, 0.3)
# haplotype frequencies in the order AB, Ab, aB, ab

Ne<-(4*n)/(2+Vo)            # variance effective population size
logsd<-sqrt(log((Vo+2)/4))  # log-normal sd required to achieve Vo 

ht<-matrix(sample(1:4, prob=hap.freq, replace=TRUE, size=2*n), n, 2)
# sample initial set of haplotypes (rows individuals)

Gt<-summaryG(ht)
# calculate allele frequencies and linkage disequilibria at time t

res<-matrix(NA, nsim,5)     
colnames(res)<-c("pAt1", "pBt1", "Lgpt1", "Lngpt1", "Ne")
# matrix for storing allele frequencies, linkage disequilibria at time t+1 and realised Ne

for(i in 1:nsim){

  prob<-exp(rnorm(n, 0, logsd))
  # generate P's

  parent<-sample(1:n, 2*n, prob=prob, replace=TRUE)
  # sample parental identities

  ht1<-matrix(apply(ht[parent,], 1, sample_gamete, r=r),n,2)
  # generate offspring haplotypes

  obs_Vo<-var(table(factor(parent, levels=1:n)))
  # observed variance in offspring number
 
  res[i,]<-c(unlist(summaryG(ht1)), (4*n)/(2+obs_Vo))
  # store results
}

deltaA<-res[,"pAt1"]-Gt$pA
deltaB<-res[,"pBt1"]-Gt$pB
# changes in allele frequency

par(mfrow=c(1,2))
plot(sapply(10:nsim, function(x){cov(deltaA[1:x], deltaB[1:x])}), ylab="Drift Covariance", xlab="Number of simulations")
# plot rolling covariance (to get an idea what it might asymptote to as nsim goes to infinity)

abline(h=(Gt$Lgp*(1-r)+Gt$Lngp*r)/(2*n), col="green") # predicted drift covariance given n=n 
abline(h=(Gt$Lgp*(1-r)+Gt$Lngp*r)/(2*Ne), col="red")  # predicted drift covariance given n=Ne 
abline(h=(Gt$Lgp+Gt$Lngp)*(1-r)/(2*Ne), col="blue")   # approximate drift covariance given n=Ne assuming Lgp=L

hist(res[,"Ne"], main="", xlab="Realised Ne")
# histogram of realised Ne
abline(v=Ne, col="red")                 # Expected Ne
abline(v=mean(res[,"Ne"]), col="blue")  # Mean realised Ne

``` 


## Recombinant Reads

Functions to calculate the probability that a recombinant sequence produced through haplotypes pairing up at random according to their frequencies is not present in a random sample of the parental haplotypes.  For `prob_novelA` the haplotype frequencies are given as two allele frequencies and the LD (as a correlation) but  `prob_novelB` the haplotype frequencies are given directly.


```{r } 

prob_novelA<-function(pA, pB, rD, nH){ 
  # pA and pB allele frequencies of reference alleles at each locus
  # rD measured as a correlation. 
  # nH the total number of parental haplotypes

  pa<-1-pA
  pb<-1-pB
  D<-rD*sqrt(pA*pa*pB*pb)


  P<-pA*pB+D
  Q<-pA*pb-D
  R<-pa*pB-D
  S<-pa*pb+D
  (P*S*(1-Q)^nH+P*S*(1-R)^nH+Q*R*(1-P)^nH+Q*R*(1-S)^nH)
}

prob_novelB<-function(P,Q,R,S, nH){ 
  # P Q R & S are the four haplotype frequencies
  # nH the total number of parental haplotypes


  P*S*(1-Q)^nH+P*S*(1-R)^nH+Q*R*(1-P)^nH+Q*R*(1-S)^nH
}
```

Function to calculate the probability of having `min` or more reads that span a pair of sites separated by `d` base-pairs with a read length of `L` base-pairs and a per individual expected coverage of `x`. 


```{r } 
prob_hap_seq<-function(d,L, x, min=2){
  y<-min:qpois(1-1e-6, x/2)
  sum((1-pbinom(min-1, y, 1-d/L))*dpois(y, x/2))
}
```

Haplotype frequencies obtained by simulating 1Mb of sequence

```{r results="hide", eval=FALSE} 

d_data<-read.table(paste0(file.path(base_path, "2_Analysis/tmp"), "/mu1.3e-9__r1.4e-8_2000Haplotypes.tsv"), header=TRUE)
# haplotype frequencies and d obatined via simulating 1Mb of sequence

N <- sum(d_data[1,c("X00", "X01", "X10", "X11")])/2
# population size

d_data[,c("X00", "X01", "X10", "X11")]<-d_data[,c("X00", "X01", "X10", "X11")]/(2*N)
# haplotype frequencies.
```

Specify some reasonable values for recombination rate, read length and coverage

```{r results="hide", eval=FALSE} 
r<-1.4e-8
L<-300
x<-1000/N
```

Compute three probabilities: probability a recombination event occurs (`prob_rec`), probability a recombinant sequence is novel (`prob_novel`) and probability of sequencing the full haplotype at least once (`prob_hapseq`). The product is the probability of sequencing a novel recombinant sequence at a locus in an individual per generation (`prob_novel_hap`). Summing over `prob_novel_hap` across loci gives the expected number of novel recombinant sequence detected per individual and multiplying this by the total number of individuals (20N, assuming 10 cage replicates and 10 wild replicates) gives the total  number of novel recombinant sequences detected across the experiment (`nhits`). 

```{r results="hide", eval=FALSE} 
for(i in 1:nrow(d_data)){
d_data$prob_rec[i]<-1-(1-r)^d_data$sep[i]
d_data$prob_novel[i]<-prob_novelB(P=d_data$X00[i], Q=d_data$X01[i], R=d_data$X10[i], S=d_data$X11[i], nH=N*2)
d_data$prob_hapseq[i]<-prob_hap_seq(d=d_data$sep[i], L=300, x=x, min=1)
}

d_data$prob_novel_hap<-d_data$prob_rec*d_data$prob_novel*d_data$prob_hapseq

nhits<-2*10*N*sum(d_data$prob_novel_hap)*150
# multiplied by 150 because genome size is 150X the simulated sequence.
```

The expected standard error for the number of generations (if the true value  is `ngen`)


```{r results="hide", eval=FALSE} 
ngen<-3.25

sqrt((1+ngen)*ngen/(2*nhits))
```

## Method of Buffalo and Coop

Comparing our method with that of Buffalo and Coop. The define ${\bf Q}$ as a matrix of covariances in allele frequency change over one generation between all pairs of generations, scaled by the average genetic diversity (Equation 16 Buffalo and Coop).  In our context this would be equivalent to covariances in allele frequency change across pairs of replicates, had each replicate been allowed to evolve for one generation:

```{r }
Q<-function(pbar1, pbar2){

   if(any(pbar2==0) | any(pbar2==1)){
     pbar2[which(pbar2==0 | pbar2==1)]<-NA
   }
   if(any(pbar1==0) | any(pbar1==1)){
     pbar1[which(pbar1==0 | pbar1==1)]<-NA
   }
   Q<-cov(t(pbar2-pbar1), use="pairwise.complete.obs")
   d<-rowMeans(pbar1*(1-pbar1), na.rm=TRUE)
   Q<-Q/sqrt(outer(d,d)) #!!!!
   return(Q)
}
``` 

The elements of the expected covariance matrix, denoted ${\bm \Sigma}$, are given in Equations 10 (off-diagonals) and 12 (diagonals). However, we replace $\mathcal{A}(r,t,s)$ with the empirical version presented in Equation 55 of B\&C which they use assuming the recombination map is known and it is not possible to distinguish between selected and neutral loci.

```{r }
Sigma<-function(L,nR, N=Inf, nrep){

  n<-nrow(L)

  s<-2*(sum(abs(cov2cor(L))*nR))/(n*(n-1))

  Sigma<-matrix(s, nrep, nrep)
  #diag(Sigma)<-1+1/N

  return(Sigma)

}
```

The function `est_Va_bc` gives an estimate of Va according to the method of Buffalo and Coop assuming allele frequencies are known perfectly, which they are. 


```{r }
est_Va_bc<-function(pbar1, pbar2, L, nR){
  
  nrep = nrow(pbar1)

  Q<-Q(pbar1, pbar2)
  Sigma<-Sigma(L, nR, nrep=nrep)

  q<-Q[upper.tri(Q, diag=TRUE)]
  a<-0.5*Sigma[upper.tri(Sigma, diag=TRUE)]
  b<-diag(nrow(Q))[upper.tri(Q, diag=TRUE)]
  
  fit_BC = lm(q~a+b-1)
  
  Ne_BC = 0.5/coef(fit_BC)["b"]
  vA_BC = coef(fit_BC)["a"]
  
  return(list(Ne_BC = Ne_BC, vA_BC = vA_BC))
  

}
```

```{r results="hide"}
rm(functions_only)
```
