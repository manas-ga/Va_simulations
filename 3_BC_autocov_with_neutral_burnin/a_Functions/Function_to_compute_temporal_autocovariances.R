#############################################################################
############ Details of the function ########################################
#############################################################################

## Input variables
# 1. start_gen: The generation from which population data is outputed in SLiM (default = 0)
# Temporal autocovariances are calculated between start_gen and the subsequent generations
# 2. end_gen: The last generation of the SLiM simulation (default = 50)
# 3. mutations_path: The path to the folder storing the text files storing information on mutations
# (Generated by a "2_Extract_mutations_genomes.py" editing the full SLiM outputs)
# 4. pop_size: Population siize (default = 1000)

## What does the function do?
# Reads the mutations.txt file for start_gen and identifies neutral mutations
# Creates a vector of allele frequencies at neutral sites in start_gen
# Reads the mutations.txt files for the subsequent generations in order
# Creates allele frequency vectors for all those generations, only using sites that are segregating in start_gen
# If a mutation segregating in start_gen is lost or fixed in any of the subsequent generations, NA is added in place of allele frequency
# Combines the allele frequency vectors corresponding to all the generations to for a matrix of allele frequencies (P)
# P: Rows are sites, and columns are generations
# Calculates del_P, a matrix of allele frequency change between successive generations
# Calculates Q
# Returns a vector containing the temporal autocovariances between start_gen and subsequent generations

## Output variables
# 1. Allele frequency matrix (P)



########################################
######## Define the function ###########
########################################

compute_temp_autocov = function(start_gen = 1, 
                                end_gen = 50, 
                                mutations_path = "C:/Academics/Post-doc/Va_simulations/3_With_neutral_burnin_msprime/b_Interim_files/Mutations", 
                                pop_size = 1000){


#################################################
####### Compute temporal autocovariances ########
#################################################

### Create an empty matrix to store allelic frequencies at neutral loci in each generation
# Only include neutral loci segregating in generation 1
# If some of the loci get fixed/lost in subsequent generations, NAs should be inserted

P = c()

# Read the mutations in start_gen

mut_0 = read.csv(paste(mutations_path, "/mutations_", start_gen, ".txt", sep = ""), sep = " ")

# Filter out selected loci

mut_0_neutral = mut_0[mut_0$s==0,]

# store the frequencies of neutral mutations in start_gen in P
# Frequency = (Number of genomes)/(2*popsize)

P = cbind(P, mut_0_neutral$Number/(2*pop_size))



### Loop through the remaining files identifying neutral mutations from start_gen and recording their frequencies

for (gen in (start_gen+1):end_gen){
  # Read the file storing mutation information
  mut = read.csv(paste(mutations_path ,"/mutations_", gen, ".txt", sep = ""), sep = " ")
  
  # Create an empty vector to store frequencies of mutations in the current generation
  freq = c()
  
  # Loop through the permanent IDs of neutral mutations segregating in start_gen
  # i.e. Loop through Permanent IDs in mut_0_neutral
  # Check if each mutation is present in the current generation
  # If present record the frequency in freq, otherwise add NA to freq
  
  for(mutation in mut_0_neutral$Permanent_ID){
    if(mutation %in% mut$Permanent_ID){freq = rbind(freq, (mut[which(mut$Permanent_ID==mutation),]$Number)/(2*pop_size))}
    else {freq = rbind(freq, NA)}
  }
  
  # Add the vector freq to P
  
  P = cbind(P, freq)
  #print(paste(round((gen-start_gen)*100/(end_gen-start_gen), 2), " % complete!"))
  
}


# Calculate the matrix of allele frequency changes

del_P = P[,2:(end_gen - start_gen + 1)] - P[,1:(end_gen - start_gen)] 


# Calculate the covariance matrix for allele frequency change

Q = cov(del_P, use = "pairwise.complete")




################### The following section can be turned on if required ###################################################

### BC (2020) say in the Methods that temporal autocovariances can be generated simply as a byproduct of tracking the minor allele frequency
### Therefore, it is more appropriate to randomly assign the reference allele
### Therefore, multiplying randomly chosen half the rows of del_P by -1 and recalculating temporal autocovariances


# Randomly select rows to be multiplied by -1

#rand_rows = sample(1:nrow(P), nrow(P)/2, replace = F)

#del_P_corr = del_P
#del_P_corr[rand_rows,] = del_P_corr[rand_rows,]*(-1)

#Q_corr = cov(del_P_corr, use = "pairwise.complete")


#################################################################################################################


## Return the temporal autocovariances between start_gen and the subsequent generations scaled by the diversity 
# in start_gen

#return(Q[6,]/(mean(complete.cases(P[,6]))*(1-mean(complete.cases(P[,6])))))
return(Q[6,])
    
}