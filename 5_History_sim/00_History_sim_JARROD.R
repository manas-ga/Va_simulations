rm(list = ls())
# source("C:/Academics/Post-doc/Va_simulations/5_History_sim/00_History_sim_JARROD.R") ## Local windows

# source("/mnt/c/Academics/Post-doc/Va_simulations/5_History_sim/00_History_sim_JARROD.R") ## Local Wsl

# source("/data/home/msamant/Manas/Va_simulations/5_History_sim/00_History_sim_JARROD.R")  ## ON VERA


####################################
######### Packages #################
####################################

#library(matlib)
library(MCMCglmm)
library(asreml)
library(Matrix)
library(rmutil)

########################################################################
########### paths of various scripts and functions #####################
########################################################################


### Base path (depending on the system) ###

if(Sys.info()["nodename"]=="vera.bio.ed.ac.uk"){
  
  base_path = "/data/home/msamant/Manas/Va_simulations/5_History_sim" ## ON VERA
  Vw_path = "/data/home/msamant/Manas/Va_simulations/5_History_sim/Vw.Rmd"  ### Jarrod's functions and other code is stored here
  
  
}else{
  
  if(Sys.info()["sysname"]=="Linux"){
    
    base_path = "/mnt/c/Academics/Post-doc/Va_simulations/5_History_sim" ## Local Wsl
    Vw_path = "/mnt/c/Users/msamant/Documents/GitHub/Va_simulations/6_Code_test/Vw.Rmd" ### Jarrod's functions and other code is stored here
    
  }else{
    
    base_path = "C:/Academics/Post-doc/Va_simulations/5_History_sim" ## Local windows
    Vw_path = "C:/Users/msamant/Documents/GitHub/Va_simulations/6_Code_test/Vw.Rmd" ### Jarrod's functions and other code is stored here
    
  }
  
}


msprime_path = file.path(base_path, "0_neutral_burnin.py")                                                    ## msprime script generating the initial sequences
msprime_output_path = paste(base_path, "/b_Interim_files/Msprime_outputs/neutral_burnin.trees", sep = "")     ## Output file generated by msprime
slim_history_path = file.path(base_path, "1_History.slim")                                                    ## SLiM script running the history
slim_expt_path = file.path(base_path, "4_Experiment.slim")                                                    ## SLiM script running the experiment
extract_genomes_path = file.path(base_path, "3_Extract_genomes.py")                                           ## Python script extracting mutations and genomes from the SLiM output for gen1
extract_mut_path = file.path(base_path, "2_Extract_mutations.py")                                             ## Python script extracting mutations for the experimental generations
slim_output_path = paste(base_path, "/b_Interim_files/SLiM_outputs", sep = "")                                ## Path where SLiM output files are stored
mutations_path = paste(base_path, "/b_Interim_files/Mutations", sep = "")                                     ## Path for text file containing mutations generated by the python script  
c_matrix_path = paste(base_path, "/b_Interim_files/C_Matrices", sep = "")                                     ## .csv file storing c matrix generated by the python script
rdata_path = paste(base_path, "/b_Interim_files/Rdata", sep = "")
output_path = paste(base_path, "/c_Output", sep = "")


###################################
###### Create file structure ######
###################################

##### Create directory that stores outputs
system(paste("mkdir -p", output_path)) # Make directory but ignore if already present

##### Create directory that stores temp files and directories therein
system(paste("mkdir -p", paste(base_path, "/b_Interim_files", sep = "")))
system(paste("rm -rf", paste(base_path, "/b_Interim_files/*", sep = ""))) # Remove the contents of this directory

system(paste("mkdir -p", paste(base_path, "/b_Interim_files/C_Matrices", sep = ""))) 
system(paste("mkdir -p", paste(base_path, "/b_Interim_files/Genomes", sep = ""))) # Not needed
system(paste("mkdir -p", paste(base_path, "/b_Interim_files/Msprime_outputs", sep = "")))
system(paste("mkdir -p", paste(base_path, "/b_Interim_files/Mutations", sep = "")))
system(paste("mkdir -p", paste(base_path, "/b_Interim_files/Rdata", sep = ""))) ## Not really needed
system(paste("mkdir -p", paste(base_path, "/b_Interim_files/SLiM_outputs", sep = "")))



#################################
#### Load Jarrod's functions ####
#################################

functions_only=TRUE ## Read only the functions

rmarkdown::render(file.path(Vw_path))


#####################################################
############ Simulation Parameters ##################
#####################################################

nsims = 15                             # Number of simulations (change scale in each simulation)
n_cages = 10                           # The number of replicate cages in the experiment
start_gen = 1                          # 
end_gen = 20000                            # How many generations should the SLiM simulation run for while simulating the history (burnin)
output_freq = 5000                      # The frequency with which SLiM outputs are to be generated for the analysis of history (optional)
ngen_expt = 3                          # How many generations should allele frequency changes be calculated over in the experiment

list_gen = seq(1,end_gen, output_freq) # List of generations for which measurements are to be made in the analysis of history
history_test = F # Plot population parameters during the history?

Ne = 1e+06                             # Effective population size
n_ind = 10000                          # Number of individuals to be sampled in msprime and then run forward in SLiM
n_ind_exp = 1000                       # The population size of the experiment. In 00_History.slim the population reduces to n_ind_exp in the last generation to simulate the sampling of the parents for the experiment
n_sample = 1000                        # Number of individuals to be sampled to construct the c matrix  (This is just because c matrices become awfully large) 

sequence_length = 1e+05               # Just have a single continuous chromosome that is simulated
r = 1.4e-06                            # Recombination rate (per site per generation)
r_expt = 1.4e-05                       # Unscaled recombination rate to be used during during the experiment (1.4e-08)
r_msp = 1.4e-08                        # Recombination rate for msprime
AtleastOneRecomb = F                   # Whether there has to be at least one recombination event
mu = 1.3e-07                           # Mutation rate during the forward simulation of the history
mu_msp = 1.3e-9                        # A separate mutation rate for the msprime simulation
mu_expt = 0                            # Mutation rate during the experiment


##############################
### DFE-related parameters ###
##############################

DFE = "g"                              # DFE can be "g" (gamma) or "n" (normal) 

# If DFE is "g"
shape = 0.2                            # Shape of the gamma DFE ##### mean = shape*scale
scale_list = seq(0.09, 0.11, length = nsims) # Vector of Scale of the gamma DFE
mut_ratio = 0.00                       # The ratio of beneficial:deleterious mutations in msprime

# If DFE is "n" need to specify the mean and the variance of the normal distribution
mean_alpha = 0
var_alpha_list = seq(0.00001, 0.00021, length = nsims) # Vector to store variance of normal DFE

############################################################################################
######## Analysis parameters can be found as arguments of the function Vw_model ############
############################################################################################

proj="BLoM" # projection type for allele frequencies: "LoM", "BLoM", "L" or "N"
LDdelta = TRUE
pa = 1
Vs = "LoNL"
method="REML"


# How is pdelta to be estimated? 
# Can be "optim" (using the function optim()), or "fixed" or "manual"(estimated by manually scanning a range of pdelta values)

pdelta_method = "optim" # "optim" or "manual" or "fixed"

if(pdelta_method=="fixed"){
  pdelta = -0.5 # Can be specified to any value
}

if(pdelta_method=="optim"){
  pdelta = NULL # This triggers the use of optim() inside the function Vw_model()
}

if(pdelta_method=="manual"){
  
  nseq<-20 # The number of times pdelta is to be varied 
  pdelta_l = -2 # Lower limit of pdelta
  pdelta_u = 2 # Upper limit of pdelta
  pdelta<-seq(pdelta_l, pdelta_u, length=nseq)
  
}




####################################################################################################################################################


# Create empty vectors to store true vA and estimates of vA from the model

vA_true = rep(NA, nsims) # Additive genetic variance
va_true = rep(NA, nsims) # Additive genic variance
vA_est = rep(NA, nsims)  # Estimated vA from the model
pdelta_est = rep(NA, nsims) # pdelta is estimated in each simulation with the help of maximum likelihood (implemented manually)


for (sim in 1:nsims){
  
    # Specify the scale of the the gamma distribution or the variance of the normal distribution of selection coefficients
  
    scale = scale_list[sim] 
    var_alpha = var_alpha_list[sim]
    
    message(paste("Simulation", sim, "in progress..."))
  


    #####################################################
    ################# Run msprime #######################
    #####################################################
    
    message("Running msprime...")
    
    system(paste("python", msprime_path, Ne, n_ind, sequence_length, r_msp, mu_msp, shape, scale, msprime_output_path, mut_ratio, DFE, mean_alpha, sqrt(var_alpha)))
    
    #####################################################
    ################# Run SLiM ##########################
    #####################################################
    
    message("Forward simulating the history using SLiM...")
    
    ### This has lot's of command line arguments. Creating separate strings for each argument
    
    arg1 = paste("-d mu=", mu, sep = "")
    arg2 = paste("-d shape=", shape, sep = "")
    arg3 = paste("-d scale=", scale, sep = "")
    arg4 = paste("-d sequence_length=", sequence_length, sep = "")
    arg5 = paste("-d r=", r, sep = "")
    
    #arg6 = paste("-d msprime_output_path=","'", msprime_output_path, "'", sep = "") # Only works on Windows
    #arg7 = paste("-d slim_output_path=", "'", slim_output_path, "'", sep = "") # Only works on Windows
    
    arg6 = paste("-d ", shQuote(paste("msprime_output_path=","'", msprime_output_path, "'", sep = "")), sep = "")
    arg7 = paste("-d ", shQuote(paste("slim_output_path=","'", slim_output_path, "'", sep = "")), sep = "") 
    
    arg8 = paste("-d end_gen=", end_gen, sep = "")
    arg9 = paste("-d output_freq=", output_freq, sep = "")
    arg10 = paste("-d mut_ratio=", mut_ratio, sep = "")
    arg11 = paste("-d n_ind_exp=", n_ind_exp, sep = "") # The population size is to be reduced to n_ind_exp in generation end_gen (to simulate sampling of the parents for the experiment)
    arg12 = paste("-d ", shQuote(paste("DFE=", "'", DFE, "'", sep = "")), sep = "")
    arg13 = paste("-d mean_alpha=", mean_alpha, sep = "")
    arg14 = paste("-d var_alpha=", var_alpha, sep = "")
    
    system(paste("slim", arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, slim_history_path))
    #system(paste("slim", arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11,  slim_history_path))
    
    
    ########################################################################################################################
    ########################################################################################################################
    #### Calculate true vA, L, and the non-recombination matrix in the last history generation (the parents' generation) ###
    ########################################################################################################################
    ########################################################################################################################
    
    message("Reading the state of the population in the parent's generation")
    
    system(paste("python", extract_genomes_path, paste(slim_output_path, "/Output_", as.integer(end_gen), ".txt", sep = ""), mutations_path, c_matrix_path, n_sample, as.integer(end_gen)))
    
    # Read genomes
    c_genome = read.csv(paste(c_matrix_path, "/c_matrix_", as.integer(end_gen), ".csv", sep =""), header=F) # as.integer done to avoid scientific notation
    
    c_genome = as.matrix(c_genome)
    
    #Convert genome data into individual data (rows are individuals and columns are allele counts {0,1 or 2} at various sites). 
    # Note that genome 1 and genome 2 are from individual 1, and so on
    
    message("Calculating the C matrix for the parents' generation...")
    
    n_individuals = nrow(c_genome)/2
    n_sites = ncol(c_genome)
    
    c_ind = c_genome[seq(1, 2*n_individuals, 2),] + c_genome[seq(2, 2*n_individuals, 2),]
    
    
    
    #### Calculate the matrix of second mixed moments of c, ie. the L matrix
    
    message("Calculating the L matrix for the parents' generation...")
    
    L = cov(c_ind/2) 
    
    # Check for 0s on the diagonal of L
    #which(diag(L)==0)
    
    ####### Notice that L has some 0s on the diagonal
    # This is happening because when I sample individuals in SLiM from a population of 10000, the sample does not contain some low frequency mutations, ie. some loci are not segregating in the sample, but are in the original population
    
    # identify the loci that are missing in the sample
    
    missing_loci = which(diag(L)==0)
    retained_loci = which(diag(L)!=0)
    
    # Trim L to contain only the retained loci
    
    L_ret = L[retained_loci,retained_loci]
    
    # Trim the c matrix to contain only the retained loci, i.e. the loci that are segregating in the sample
    
    c_ind_ret = c_ind[,retained_loci]
    
    # Correlation matrix
    
    #R = cov2cor(L_ret)
    
    
    ## Read the list of mutations output generated by SLiM and subsequently cropped out as a separate file by Python
    # From the first generation
    
    mutations_0 = read.table(paste(mutations_path, "/Mutations_", as.integer(end_gen), ".txt", sep = ""), header=T, sep = " ")
    
    # Sort mutations based on the Temp_ID, so that the order of loci matches the order in the C and L matrices
    
    mutations_0 = mutations_0[order(mutations_0$Temp_ID),]
    
    # Trim mutations to contain only the retained loci, i.e. the loci that are segregating in the sample
    
    mutations_ret = mutations_0[retained_loci,]
    
    # Calculate the number of loci that are retained
    
    n_sites_ret = ncol(c_ind_ret)
    
    ################################
    ### Calculate true vA and va ###
    ################################
    
    message("Computing the actual Va for the starting population...")
    
    
    list_alpha = 2*(mutations_ret$s)
    
    vA_true[sim] = t(list_alpha)%*%L_ret%*%list_alpha  # Additive genetic variance
    va_true[sim] = sum(diag(L_ret)*list_alpha*list_alpha) # Additive genic variance
    
    
    
      
    message("Calculating the the matrix of non-recombinant fractions for the starting population...")
    
    #dist = matrix(0, nrow(L_ret), nrow(L_ret)) # Matrix of paired distances
    
    #### Loop through columns 
    
    #for (site in 1:nrow(L_ret)){
    #  dist[, site] = abs(mutations_ret$Position - mutations_ret$Position[site])
    #}
    
    #NRF = 1 - 0.5*(1 - exp(-2*dist*r_expt))
    
    # Calculate the non-recombinant fraction using Jarrod's function
    
    NRF = form_nR(mutations_ret$Position, r_expt, sequence_length, AtleastOneRecomb)
      
      
    
    #######################################################################################
    #######################################################################################
    ################################## Experiment #########################################
    #######################################################################################
    #######################################################################################
    
    message("Forward simulating the experiment using SLiM...")
    
    # Create empty vector to create the data frame containing the following variables as columns:
    # 1. Raw delta P
    # 2. Projected delta P
    # 3. Cage ID (replicate)
    # 4. Locus ID
    
    d_proj = c()
    d_raw = c()
    P_matrix = c()
    
    ### Loop over the cage replicates
    
    for (cage in (1:n_cages)){
      
      message(paste("Cage", cage, "of simulation", sim, "in progress..."))
      
      #######################
      ###### run SLiM #######
      #######################   
        
      # SLiM by default generates random seeds in a very odd way (based on the clock and process ID)
      # Generate a random seed for SLiM
      
      #slim_seed = sample(1:100000, 1)
      
      
      
      ### This has lot's of command line arguments. Creating separate strings for each argument
      
      expt_arg1 = paste("-d mu=", mu_expt, sep = "")
      expt_arg2 = paste("-d shape=", shape, sep = "")
      expt_arg3 = paste("-d scale=", scale, sep = "")
      expt_arg4 = paste("-d sequence_length=", sequence_length, sep = "")
      expt_arg5 = paste("-d r=", r_expt, sep = "")
      
      #arg6 = paste("-d msprime_output_path=","'", msprime_output_path, "'", sep = "") # Only works on Windows
      
      expt_arg6 = paste("-d ", shQuote(paste("slim_output_path=","'", slim_output_path, "'", sep = "")), sep = "") 
      expt_arg7 = paste("-d mut_ratio=", mut_ratio, sep = "")
      expt_arg8 = paste("-d end_gen=", end_gen, sep = "")
      expt_arg9 = paste("-d ", shQuote(paste("DFE=", "'", DFE, "'", sep = "")), sep = "")
      expt_arg10 = paste("-d mean_alpha=", mean_alpha, sep = "")
      expt_arg11 = paste("-d var_alpha=", var_alpha, sep = "")
      expt_arg12 = paste("-d ngen_expt=", ngen_expt, sep = "")
      
      
      system(paste("slim", expt_arg1, expt_arg2, expt_arg3, expt_arg4, expt_arg5, expt_arg6, expt_arg7, expt_arg8, expt_arg9, expt_arg10, expt_arg11, expt_arg12, slim_expt_path))
      
      
      ###############################
      ###### extract mutations ######
      ###############################
      
      # There are three command line arguments (1. Path of the SLiM output file, 2. Path where mutations are to be written, 3. gen) 
      
      
      message("Extracting mutations...")
      
      for (gen in (end_gen + 1):(end_gen + 1 + ngen_expt)){
        message(paste((gen-end_gen)*100/5, "% extracted..."))
        system(paste("python", extract_mut_path, paste(slim_output_path, "/Output_experiment_", as.integer(gen), ".txt", sep = ""), mutations_path, as.integer(gen))) # as.integer done to avoid scientific notation
      }
      
      
    
      
      ### Create an empty matrix to store allelic frequencies in each generation
      
      # If some of the loci get fixed/lost in subsequent generations, NAs should be inserted
      
      message("Storing allele frequencies...")
      
      # Create an empty vector to store allele frequencies
      
      P = c()
      
      
      # store the frequencies in the parent's generation in P
      # Frequency = (Number of genomes)/(2*popsize)
      
      P = cbind(P, mutations_ret$Number/(2*n_ind_exp))
      
      
      
      ### Loop through the generations of the experiment identifying mutations that were present in the parents' generation (using permanent IDs) and recording their frequencies
      
      for (gen in (end_gen+1):(end_gen+ngen_expt+1)){
        # Read the file storing mutation information
        mut = read.csv(paste(mutations_path ,"/Mutations_", as.integer(gen), ".txt", sep = ""), sep = " ") # as.integer gets rid of scientific notation
        
        # Sort mutations based on the Temp_ID, so that the order of loci matches the order in the C and L matrices
        
        mut = mut[order(mut$Temp_ID),]
        
        # Create an empty vector to store frequencies of mutations in the current generation
        freq = c()
        
        # Loop through the permanent IDs of  mutations segregating in end_gen (parents' generation)
        # i.e. Loop through Permanent IDs in mutations_1
        # Check if each mutation is present in the current generation
        # If present, record the frequency in freq, otherwise add either 0 or 1 to freq using the round() function
        
        for(mutation in mutations_ret$Permanent_ID){
          if(mutation %in% mut$Permanent_ID){freq = rbind(freq, (mut[which(mut$Permanent_ID==mutation),]$Number)/(2*n_ind_exp))
          }else{
            freq = rbind(freq, round(P[which(mutations_ret$Permanent_ID==mutation), gen - end_gen]))
            #print(round(P[which(mutations_1$Permanent_ID==mutation), gen -1]))
          }
        }
        
        # Add the vector freq to P
        
        P = cbind(P, freq)
        #print(paste(round((gen-start_gen)*100/(end_gen-start_gen), 2), " % complete!"))
        
      }
     
      P_matrix = rbind(P_matrix, P)
      
    }
    
    
    ##### Calculate matrices of allele frequencies with rows as replicates ######
    
    pbar1 = matrix(NA, nrow = n_cages, ncol = n_sites)
    pbar2 = matrix(NA, nrow = n_cages, ncol = n_sites)
    for (i in 1:n_cages){
      pbar1[i,] = P_matrix[((i-1)*n_sites + 1):((i-1)*n_sites + n_sites),2] ## Matrix of frequencies at the start of the experiment (ie F1 generation)
    }
    
    for (i in 1:n_cages){
      pbar2[i,] = P_matrix[((i-1)*n_sites + 1):((i-1)*n_sites + n_sites),ngen_expt + 2] ## Matrix of frequencies at the end of the experiment
      
      
    }
    
    
    ##################################################
    ######### Jarrod's code for analysis #############
    ##################################################
    
    message("Fitting the model...")
    
    if(pdelta_method=="manual"){
    
    ### Fit the model varying pdelta, select the estimate that has the highest log likelihood
    
        LL<-vA_est_temp<-1:nseq # Creating empty vectors to store pdelta and estimated vA in each model
        
        
        for(i in 1:nseq){
          
          save.image(file = paste(output_path, "/Output_temp", ".RData", sep ="")) # Save the output to investigate when things crash due to segfaults
          m1<-Vw_model(C0 = c_ind_ret/2,          # parental genotypes (rows individuals, columns loci, coded as 0, 1/2 or 1) 
                       nR = NRF,          # matrix of non-recombinant probabilities between loci
                       pbar1 = pbar1,       # vector of allele frequencies at time-point 1
                       ngen1=1,     # number of generations between parents and time-point 1
                       pbar2 = pbar2,       # vector of allele frequencies at time-point 2
                       ngen2 = ngen_expt + 1,       # number of generations between parents and time-point 2
                       nind = nrow(c_ind_ret),        # population size in each replicate
                       proj="BLoM", # projection type for allele frequencies: "LoM", "BLoM", "L" or "N"
                       LDdelta = TRUE,
                       pa = pa,
                       pdelta = pdelta[i],
                       Vs = Vs,
                       method = method,
                       L = NULL,    # list with elements UL and DL
                       svdL = NULL,    # list with elements UL and DL
                       tol = sqrt(.Machine$double.eps))
          
          LL[i]<-m1$model$loglik
          vA_est_temp[i]<-m1$Vw_est
          message(paste("Finding the best pdelta...", round((i/nseq)*100), "% complete"))
        }
        
        vA_est[sim] = vA_est_temp[which(LL == max(LL))] # Store the estimate from the model with the highest log likelihood
        pdelta_est[sim] = pdelta[which(LL == max(LL))]
        plot(vA_est~vA_true)
        abline(0,1)
    
    }
    
    
    if(pdelta_method=="fixed"|pdelta_method=="optim"){
      
      save.image(file = paste(output_path, "/Output_temp", ".RData", sep ="")) # Save the output to investigate when things crash due to segfaults
      m1<-Vw_model(C0 = c_ind_ret/2,          # parental genotypes (rows individuals, columns loci, coded as 0, 1/2 or 1) 
                   nR = NRF,          # matrix of non-recombinant probabilities between loci
                   pbar1 = pbar1,       # vector of allele frequencies at time-point 1
                   ngen1=1,     # number of generations between parents and time-point 1
                   pbar2 = pbar2,       # vector of allele frequencies at time-point 2
                   ngen2 = ngen_expt + 1,       # number of generations between parents and time-point 2
                   nind = nrow(c_ind_ret),        # population size in each replicate
                   proj="BLoM", # projection type for allele frequencies: "LoM", "BLoM", "L" or "N"
                   LDdelta = TRUE,
                   pa = pa,
                   pdelta = pdelta,
                   Vs = Vs,
                   method = method,
                   L = NULL,    # list with elements UL and DL
                   svdL = NULL,    # list with elements UL and DL
                   tol = sqrt(.Machine$double.eps))
      
      
      vA_est[sim] = m1$Vw_est # Store the estimate from the model with the highest log likelihood
      pdelta_est[sim] = m1$pdelta # The sample() functions ensures that only one value is selected in case there are multiple points with the highest LL
      plot(vA_est~vA_true)
      abline(0,1)
      
    }
    

    
    
}


save.image(file = paste(output_path, "/Output", gsub(" ", "_", Sys.time()), ".RData", sep =""))

pdf(paste(output_path, "/Output_",gsub(" ", "_", Sys.time()), ".pdf", sep = ""), onefile = F)

plot(vA_est~vA_true)
abline(0,1)

dev.off()