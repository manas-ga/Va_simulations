rm(list = ls())

# source("C:/Users/msamant/Documents/GitHub/Va_simulations/5_History_sim/00_History_sim_JARROD.R") ## Local windows

# source("/mnt/c/Users/msamant/Documents/GitHub/Va_simulations/5_History_sim/00_History_sim_JARROD.R") ## Local Wsl

# source("/data/home/msamant/Manas/Va_simulations/Github/Va_simulations/5_History_sim/00_History_sim_JARROD.R")  ## ON VERA


########################################################################
########### paths of various scripts and functions #####################
########################################################################


### Base path and path to Vw.Rmd (file containing Jarrod's functions) (depending on the system) ###

if(Sys.info()["nodename"]=="vera.bio.ed.ac.uk"){
  
  base_path = "/data/home/msamant/Manas/Va_simulations/Github/Va_simulations/5_History_sim" ## ON VERA
  Vw_path = "/data/home/msamant/Manas/Va_simulations/Github/Va_simulations/6_Code_Test/Vw.Rmd"  ### Jarrod's functions and other code is stored here
  
  
}else{
  
  if(Sys.info()["sysname"]=="Linux"){
    
    base_path = "/mnt/c/Users/msamant/Documents/GitHub/Va_simulations/5_History_sim" ## Local Wsl
    Vw_path = "/mnt/c/Users/msamant/Documents/GitHub/Va_simulations/6_Code_test/Vw.Rmd" ### Jarrod's functions and other code is stored here

  }else{
    
    base_path = "C:/Users/msamant/Documents/GitHub/Va_simulations/5_History_sim" ## Local windows
    Vw_path = "C:/Users/msamant/Documents/GitHub/Va_simulations/6_Code_test/Vw.Rmd" ### Jarrod's functions and other code is stored here
    
  }
  
}

# Paths to various scripts that are used for running the simulations and extracting information from SLiM outputs

msprime_burnin_path = file.path(base_path, "0_neutral_burnin.py")                                             ## msprime script generating the initial sequences
slim_history_path = file.path(base_path, "1_History.slim")                                                    ## SLiM script running the history
msprime_add_neutral_path = file.path(base_path, "1_History_add_neutral_mut.py")                               ## msprime script that adds neutral mutations to the tree sequence generated by 1_History.slim
slim_expt_path = file.path(base_path, "4_Experiment.slim")                                                    ## SLiM script running the experiment
extract_genomes_path = file.path(base_path, "3_Extract_genomes.py")                                           ## Python script extracting mutations and genomes from the SLiM output file 
extract_mut_path = file.path(base_path, "2_Extract_mutations.py")                                             ## Python script extracting mutations from the SliM output file

# Paths to various temporary directories

slim_output_path = paste(base_path, "/b_Interim_files/SLiM_outputs", sep = "")                                ## Path where SLiM and msprime output files are stored
mutations_path = paste(base_path, "/b_Interim_files/Mutations", sep = "")                                     ## Path for text file containing mutations generated by the python script  
c_matrix_path = paste(base_path, "/b_Interim_files/C_matrices", sep = "")                                     ## .csv file storing c matrix generated by the python script
output_path = paste(base_path, "/c_Output", sep = "")


###################################
###### Create file structure ######
###################################

##### Create directory that stores outputs
system(paste("mkdir -p", output_path)) # Make directory but ignore if already present

##### Create directory that stores temp files and directories therein
system(paste("mkdir -p", paste(base_path, "/b_Interim_files", sep = "")))
system(paste("rm -rf", paste(base_path, "/b_Interim_files/*", sep = ""))) # Remove the contents of this directory

system(paste("mkdir -p", paste(base_path, "/b_Interim_files/C_matrices", sep = ""))) 
system(paste("mkdir -p", paste(base_path, "/b_Interim_files/Mutations", sep = "")))
system(paste("mkdir -p", paste(base_path, "/b_Interim_files/SLiM_outputs", sep = "")))


##### Create a spreadsheet to store cumulative data across all simulations (only if it doesn't exist already)

# Assign a "Set_ID" to each set of simulations 
# The set ID is the name of the system + time at which this script starts running. It stays constant throughout (for all the simulations run in that particular set).

Set_ID = as.character(paste(Sys.info()["nodename"], Sys.time()))


if(!file.exists(paste(output_path, "/Data.csv", sep = ""))){
  col_names = as.matrix(t(c("Set_ID","Time","end_gen", "ngen_expt", "Ne", "n_ind_exp", "n_cages", "sequence_length", "r_msp", "r", "r_expt", "mu_msp", "mu", "mu_neutral", "shape", "scale", "mut_ratio", "proj", "LDdelta", "pa", "Vs", "randomise", "pdelta_method", "bdelta_method", "vA_true", "vA_est", "pdelta_est", "pdelta_var_est", "bdelta_intercept_est", "bdelta_slope_est", "seg_sites", "bdelta_var_est", "va_lost")))
  write.table(col_names, file = paste(output_path, "/Data.csv", sep = ""),col.names = FALSE, row.names = FALSE, sep = ",")
}


####################################
######### Packages #################
####################################

library(MCMCglmm)
library(asreml)
library(Matrix)
library(rmutil)
library(pryr) ## For tracking memory usage using mem_used()
library(bigalgebra)

#################################
#### Load Jarrod's functions ####
#################################

functions_only=TRUE ## Read only the functions

rmarkdown::render(file.path(Vw_path))

#####################################################
############ Simulation Parameters ##################
#####################################################

simulate = TRUE                        # To run the simulation or not
analyse = TRUE                         # To perform the analysis on simulated data or not
record = FALSE                          # Should the data of the simulations be appended to "data.csv" 

nsims = 5                              # Number of simulations (change scale in each simulation)
n_cages = 10                           # The number of replicate cages in the experiment
start_gen = 1                          # 
end_gen = 20000                        # How many generations should the SLiM simulation run for while simulating the history (burnin)
output_freq = 5000                     # The frequency with which SLiM outputs are to be generated for the analysis of history 
ngen_expt = 3                          # How many generations should allele frequency changes be calculated over in the experiment


###########################################
########### Pop gen parameters ############
###########################################

Ne = 1.33e+06                          # Effective population size
n_ind = 2500                          # Number of individuals to be sampled in msprime and then run forward in SLiM
n_ind_exp = 1000                       # The population size of the experiment. In 00_History.slim the population reduces to n_ind_exp in the last generation to simulate the sampling of the parents for the experiment
n_sample = n_ind_exp                        # Number of individuals to be sampled to construct the c matrix  (This is just because c matrices become awfully large). Typically should be the same as n_ind_exp 

sequence_length = 1e+06                # Just have a single continuous chromosome that is simulated
r = 1.4e-07                            # Recombination rate (per site per generation) during the forward simulation of history
r_expt = 1.4e-06                       # Recombination rate to be used during during the experiment (Drosophila melanogaster ~ 1.4e-08)
r_msp = 1.4e-09                        # Recombination rate for the initial msprime simulation
AtleastOneRecomb = FALSE               # Whether there has to be at least one recombination event

#mu = 1.3e-06                          # Mutation rate of non_neutral mutations during the forward simulation of the history
mu_list = seq(3.45e-07, 3.45e-06, length = nsims)  # If mu is to be varied in order to vary true Vw # (1.5-6.0 e-06 works splendidly)
#mu_neutral_list = (mu_list/3)*(n_ind/Ne)        # Mutation rate of neutral mutations to be back-simulated using msprime on the tree sequence generated by the forward slim simulation
#mu_neutral = 6.5e-09
#mu_msp = 1.3e-10                         # A separate mutation rate for the msprime simulation
mu_expt = 0                             # Mutation rate during the experiment


##############################
### DFE-related parameters ###
##############################

DFE = "g"                              # DFE can be "g" (gamma) or "n" (normal) 

# If DFE is "g"
shape = 0.3                                  # Shape of the gamma DFE ##### mean = shape*scale
scale_list = seq(0.05, 0.05, length = nsims)  # Vector of Scale of the gamma DFE
mut_ratio = 0                          # The ratio of beneficial:deleterious mutations in msprime

# If DFE is "n" need to specify the mean and the variance of the normal distribution
mean_alpha = 0
var_alpha_list = seq(0.00002, 0.0002, length = nsims) # Vector to store variance of normal DFE

############################################################################################
########## Analysis parameters to be fed as arguments of the function Vw_model  ############
############################################################################################

proj="BLoM" # projection type for allele frequencies: "LoM", "BLoM", "L" or "N"
LDdelta = FALSE
pa = 1
Vs = "LoNL" # "L" or "LoNL"
method="REML" # Can be "REML" or "MCMC"
randomise = TRUE # Should the reference allele be randomised for analysis?
bigalgebra = FALSE # Should bigalgebra be used for eigendecomposition?

# How is pdelta to be estimated? 
# Can be "optim" (using the function optim()), or "fixed" or "manual"(estimated by manually scanning a range of pdelta values)

pdelta_method = "optim" # "optim" or "manual" or "fixed". If "this is "no_analysis", the estimate of Vw is not calculated, but the rest of the code still runs.

if(pdelta_method=="fixed"){
  pdelta = 0 # Can be specified to any value
}

if(pdelta_method=="optim"){
  pdelta = NA # This triggers the use of optim() inside the function Vw_model()
}

if(pdelta_method=="manual"){
  
  nseq<-20 # The number of times pdelta is to be varied 
  pdelta_l = -1 # Lower limit of pdelta
  pdelta_u = 1 # Upper limit of pdelta
  pdelta<-seq(pdelta_l, pdelta_u, length=nseq)
  
}

# How should bdelta[1] (intercept) and bdelta[2] (slope of (p-q)) be estimated

bdelta_method = "estimate" # Can be "fixed" or "estimate"

if(bdelta_method=="estimate"){
  bdelta = c(NA, NA)
}else{
  bdelta = c(0, 0) # This only estimates the slope while keeping the intercept fixed at 0
}


####################################################################################################################################################

if(!DFE%in%c("n", "g")){stop("DFE must be one of 'g', 'n'")}
if(!pdelta_method%in%c("optim", "fixed", "manual", "no_analysis")){stop("pdelta_method must be one of 'optim', 'fixed', 'manual', 'no_analysis'")}
if(!bdelta_method%in%c("estimate", "fixed")){stop("pdelta_method must be one of 'estimate', 'fixed'")}
if(!randomise%in%c(TRUE, FALSE)){stop("randomise must be one of TRUE or FALSE")}
if(!simulate%in%c(TRUE, FALSE)){stop("simulate must be one of TRUE or FALSE")}
if(!analyse%in%c(TRUE, FALSE)){stop("analyse must be one of TRUE or FALSE")}

####################################################################################################################################################


# Create empty vectors to store true vA and estimates of vA from the model

va_lost = rep(NA, nsims)
vA_true = rep(NA, nsims) # Additive genetic variance
va_true = rep(NA, nsims) # Additive genic variance
vA_est = rep(NA, nsims)  # Estimated vA from the model
pdelta_est = rep(NA, nsims) # pdelta is estimated in each simulation with the help of maximum likelihood (implemented manually)
pdelta_var_est = rep(NA, nsims)
bdelta_intercept_est = rep(NA, nsims) # Estimate of bdelta[1] from the model
bdelta_slope_est = rep(NA, nsims) # Estimate of bdelta[2] from the model
bdelta_var_est = rep(NA, nsims)
seg_sites = rep(NA, nsims) # Number of segregating sites in the parents' generation in each simulation
mem = c() # Create an empty vector to track memory, to investigate crashes

for (sim in 1:nsims){
  
  if(simulate){
  
      # Specify the scale of the the gamma distribution or the variance of the normal distribution of selection coefficients
    
      scale = scale_list[sim] 
      var_alpha = var_alpha_list[sim]
      
      # Specify the mutation rate for the SLiM history simulation
      
      mu = mu_list[sim]
      mu_msp = mu/10000
      mu_neutral = 0
      #mu_neutral = 0
      
      
      message(paste("Simulation", sim, "in progress..."))
    
  
  
      #####################################################
      ############# Run msprime (neutral burnin) ##########
      #####################################################
      
      message("Running msprime...")
      
      system(paste("python", msprime_burnin_path, Ne, n_ind, sequence_length, r_msp, mu_msp, shape, scale, slim_output_path, mut_ratio, DFE, mean_alpha, sqrt(var_alpha), sim))
      
      ###############################################################
      ################# Simulate the history in SLim ################
      ###############################################################
      
      message("Forward simulating the history using SLiM...")
      
      ### This has lot's of command line arguments. Creating separate strings for each argument
      
      arg1 = paste("-d mu=", mu, sep = "")
      arg2 = paste("-d shape=", shape, sep = "")
      arg3 = paste("-d scale=", scale, sep = "")
      arg4 = paste("-d sequence_length=", sequence_length, sep = "")
      arg5 = paste("-d r=", r, sep = "")
      arg6 = paste("-d ", shQuote(paste("msprime_output_path=","'", slim_output_path, "'", sep = "")), sep = "") # Path where the msprime burnin is stored (it's same as slim_output_path)
      
      # Could have got rid of arg6 since it is identical to arg7, but keeping it so as to avoid having to edit downstream code
      
      arg7 = paste("-d ", shQuote(paste("slim_output_path=","'", slim_output_path, "'", sep = "")), sep = "") 
      arg8 = paste("-d end_gen=", end_gen, sep = "")
      arg9 = paste("-d output_freq=", output_freq, sep = "")
      arg10 = paste("-d mut_ratio=", mut_ratio, sep = "")
      arg11 = paste("-d n_ind_exp=", n_ind_exp, sep = "") # The population size is to be reduced to n_ind_exp in generation end_gen (to simulate sampling of the parents for the experiment)
      arg12 = paste("-d ", shQuote(paste("DFE=", "'", DFE, "'", sep = "")), sep = "")
      arg13 = paste("-d mean_alpha=", mean_alpha, sep = "")
      arg14 = paste("-d var_alpha=", var_alpha, sep = "")
      arg15 = paste("-d simulation=", sim, sep = "")
      
      system(paste("slim", arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, slim_history_path))
      
      ###################################################################
      ############### Add neutral mutations using msprime ###############
      ###################################################################
      
      message("Adding neutral mutations...")
      
      system(paste("python", msprime_add_neutral_path, slim_output_path, mu_neutral, sim))
      
      
      ###################################################
      ######### Simulate the experiment in SLiM #########
      ###################################################
      
      message("Forward simulating the experiment using SLiM...")
      
      ### Loop over the cage replicates
      
      for (cage in (1:n_cages)){
        
        message(paste("Cage", cage, "of simulation", sim, "in progress..."))
        
        
        ### This has lot's of command line arguments. Creating separate strings for each argument
        
        expt_arg1 = paste("-d mu=", mu_expt, sep = "")
        expt_arg2 = paste("-d shape=", shape, sep = "")
        expt_arg3 = paste("-d scale=", scale, sep = "")
        expt_arg4 = paste("-d sequence_length=", sequence_length, sep = "")
        expt_arg5 = paste("-d r=", r_expt, sep = "")
        expt_arg6 = paste("-d ", shQuote(paste("slim_output_path=","'", slim_output_path, "'", sep = "")), sep = "") 
        expt_arg7 = paste("-d mut_ratio=", mut_ratio, sep = "")
        expt_arg8 = paste("-d end_gen=", end_gen, sep = "")
        expt_arg9 = paste("-d ", shQuote(paste("DFE=", "'", DFE, "'", sep = "")), sep = "")
        expt_arg10 = paste("-d mean_alpha=", mean_alpha, sep = "")
        expt_arg11 = paste("-d var_alpha=", var_alpha, sep = "")
        expt_arg12 = paste("-d ngen_expt=", ngen_expt, sep = "")
        expt_arg13 = paste("-d simulation=", sim, sep = "")
        expt_arg14 = paste("-d cage=", cage, sep = "")
        
        system(paste("slim", expt_arg1, expt_arg2, expt_arg3, expt_arg4, expt_arg5, expt_arg6, expt_arg7, expt_arg8, expt_arg9, expt_arg10, expt_arg11, expt_arg12, expt_arg13, expt_arg14, slim_expt_path))
        
      }
    
  }
  
  if(analyse){
      
      ##################################################################################
      ##################################################################################
      ########                 Analysis of the parents' generation               #######
      ######## Calculate c matrix, L, true Vw, and the non-recombination matrix  #######
      ##################################################################################
      ##################################################################################
      
      
      message("Reading the state of the population in the parent's generation...")
      
      system(paste("python", 
                   extract_genomes_path,                                                      # Path of the python script (3_Extract_genomes.py)
                   paste(slim_output_path, "/sim", sim, "_output_parents.txt", sep = ""),     # Path of the .txt file containing the SLiM output for the parent's generation (sys.argv[1])
                   paste(mutations_path, "/mutations_parents.txt", sep = ""),                 # Path of the .txt output file containing the mutations in the parents' generation (sys.argv[2])
                   paste(c_matrix_path, "/c_matrix_parents.csv", sep = ""),                   # Path of the .csv output file containing the c matrix for genomes in the parents' generation (sys.argv[3])
                   n_sample))                                                                 # Number of individuals to be sampled randomly to construct the c matrix (just for space issues). Typically should be set to same as n_ind_exp
      
      # Read genomes
      c_genome = read.csv(paste(c_matrix_path, "/c_matrix_parents.csv", sep =""), header=F) # as.integer done to avoid scientific notation
      
      c_genome = as.matrix(c_genome)
      
      # Convert genome data into individual data (rows are individuals and columns are allele counts {0,1 or 2} at various sites). 
      # Note that genome 1 and genome 2 are from individual 1; 3 and 4 are from individual 2, and so on
      
      message("Calculating the C matrix for the parents' generation...")
      
      n_individuals = nrow(c_genome)/2
      n_sites = ncol(c_genome)
      
      c_ind = c_genome[seq(1, 2*n_individuals, 2),] + c_genome[seq(2, 2*n_individuals, 2),]
      
      # Remove c_genome to save memory
      rm("c_genome")
      
      # If one samples individuals from the parents' generation while building the c matrix (i.e. when sample_size is less than n_ind_exp), the sample may not contain some low frequency mutations, i.e. some loci are not segregating in the sample, but are in the parents' population
      
      # identify the loci that are missing in the sample
      
      missing_loci = which(colSums(c_ind)==0)
      retained_loci = which(colSums(c_ind)!=0)
      
      # Trim the c matrix to contain only the retained loci, i.e. the loci that are segregating in the sample
      
      c_ind = c_ind[,retained_loci]
      
      
      
      ## Read the list of mutations output generated by SLiM and subsequently cropped out as a separate file by Python (for the parents' generation)
      
      mutations_0 = read.table(paste(mutations_path, "/mutations_parents.txt", sep = ""), header=T, sep = " ")
      
      # Sort mutations based on the Temp_ID, so that the order of loci matches the order in the C and L matrices
      
      mutations_0 = mutations_0[order(mutations_0$Temp_ID),]
      
      # Trim mutations to contain only the retained loci, i.e. the loci that are segregating in the sample
      
      mutations_0 = mutations_0[retained_loci,]
      
      # Calculate the number of loci that are retained
      
      n_individuals = nrow(c_ind)/2
      n_sites_ret = ncol(c_ind)
      seg_sites[sim] = n_sites_ret
      
      message(paste("There are", n_sites_ret, "Segregating sites in the parents' generation..."))
      
      
      
      
      
      ### Calculate true vA (additive genetic variance) and va (additive genic variance) 
      
      message("Computing the true Va in the parents' generation...")
      
      
      list_alpha = 2*(mutations_0$s)
      diversity = (colMeans(c_ind/2))*(1 - colMeans(c_ind/2))/2
      va_true[sim] = sum(diversity*list_alpha*list_alpha)     # Additive genic variance
      message(paste("The true Va in the parents' generation is", va_true[sim]))
      
      if(pdelta_method!="no_analysis"){
        
      message("Calculating L in the parents' generation...")
        
      L = cov(c_ind/2)*(n_individuals-1)/(n_individuals)
      L = L[retained_loci, retained_loci] # Trim L to contain only the retained loci
      
      message("Calculating the true Vw in the parents' generation...")
      
      vA_true[sim] = t(list_alpha)%*%L%*%list_alpha         # Additive genetic variance
      rm("L") # remove L to save memory
      
      message(paste("The true Vw in the parents' generation is", vA_true[sim]))
      
      message("Calculating the the matrix of non-recombinant fractions for the parents' generation...")
      
      # Calculate the non-recombinant fraction using Jarrod's function
      
      NRF = form_nR(mutations_0$Position, r_expt, sequence_length, AtleastOneRecomb)
      }
      
      
      
      
      
      ############################################################################
      ############################################################################
      ####### Calculate allele frequencies in the experiment for each cage #######
      ############################################################################
      ############################################################################  
      
      # Create empty vector to create the data frame containing the following variables as columns:
      # 1. Raw delta P
      # 2. Projected delta P
      # 3. Cage ID (replicate)
      # 4. Locus ID
      
      d_proj = c()
      d_raw = c()
      P_matrix = c()  
      
      for (cage in (1:n_cages)){
        
        ###############################
        ###### extract mutations ######
        ###############################
        
        
        # There are two command line arguments (1. Path of the SLiM output file, 2. Path where mutations are to be written) 
        
        
        message(paste("Extracting mutations and storing allele frequencies in cage ", cage, " of simulation ", sim, "...", sep = ""))
        
        for (gen in (end_gen + 1):(end_gen + 1 + ngen_expt)){
          #message(paste((gen-end_gen)*100/5, "% extracted..."))
          system(paste("python", 
                       extract_mut_path, 
                       paste(slim_output_path, "/sim", sim, "_cage", cage, "_output_experiment_", as.integer(gen), ".txt", sep = ""), 
                       paste(mutations_path, "/mutations_", as.integer(gen), ".txt", sep = ""))) # as.integer done to avoid scientific notation
        }
        
        
      
        
        ### Create an empty matrix to store allelic frequencies in each generation
        
        # If some of the loci get fixed/lost in subsequent generations, NAs should be inserted
        
        # Create an empty vector to store allele frequencies
        
        P = c()
        
        
        # store the frequencies in the parent's generation in P
        # Frequency = (Number of genomes)/(2*popsize)
        
        P = cbind(P, mutations_0$Number/(2*n_ind_exp))
        
        
        
        ### Loop through the generations of the experiment identifying mutations that were present in the parents' generation (using permanent IDs) and recording their frequencies
        
        for (gen in (end_gen+1):(end_gen+ngen_expt+1)){
          
          # Read the file storing mutation information
          mut = read.csv(paste(mutations_path ,"/mutations_", as.integer(gen), ".txt", sep = ""), sep = " ") # as.integer gets rid of scientific notation
          
          # Sort mutations based on the Temp_ID, so that the order of loci matches the order in the C and L matrices
          
          mut = mut[order(mut$Temp_ID),]
          
          # Create an empty vector to store frequencies of mutations in the current generation
          freq = c()
          
          # Loop through the permanent IDs of  mutations segregating in end_gen (parents' generation)
          # i.e. Loop through Permanent IDs in mutations_1
          # Check if each mutation is present in the current generation
          # If present, record the frequency in freq, otherwise add either 0 or 1 to freq using the round() function
          
          for(mutation in mutations_0$Permanent_ID){
            if(mutation %in% mut$Permanent_ID){freq = rbind(freq, (mut[which(mut$Permanent_ID==mutation),]$Number)/(2*n_ind_exp))
            }else{
              freq = rbind(freq, round(P[which(mutations_0$Permanent_ID==mutation), gen - end_gen]))
              #print(round(P[which(mutations_1$Permanent_ID==mutation), gen -1]))
            }
          }
          
          # Add the vector freq to P
          
          P = cbind(P, freq)
          #print(paste(round((gen-start_gen)*100/(end_gen-start_gen), 2), " % complete!"))
          
        }
       
        P_matrix = rbind(P_matrix, P)
        
      }
      
      
      ##### Calculate matrices of allele frequencies with rows as replicates ######
      
      pbar1 = matrix(NA, nrow = n_cages, ncol = n_sites)
      pbar2 = matrix(NA, nrow = n_cages, ncol = n_sites)
      for (i in 1:n_cages){
        pbar1[i,] = P_matrix[((i-1)*n_sites + 1):((i-1)*n_sites + n_sites),2] ## Matrix of frequencies at the start of the experiment (ie F1 generation)
      }
      
      for (i in 1:n_cages){
        pbar2[i,] = P_matrix[((i-1)*n_sites + 1):((i-1)*n_sites + n_sites),ngen_expt + 2] ## Matrix of frequencies at the end of the experiment
        
        
      }
      
      # Calculate the additive genic variance that is lost between the parents and the first generation of the experiment in replicate 1
      
      fixed = which(pbar1[1,]==0|pbar1[1,]==1)
      va_lost[sim] = sum(diversity[fixed]*list_alpha[fixed]*list_alpha[fixed])
      
      message(paste("The percentage lost Va in between the parents' generation and the experiment in Cage 1 is", va_lost[sim]*100/va_true[sim], "%"))
      
      ################################################################
      ######## Randomise the reference allele in the c matrix ########
      ################################################################
      
      # Randomly change the reference allele
      # This can be done as follows:
      # Add 0s to the allele counts of those alleles that stay the same, and -2 to those alleles that are to be switched
      # Then take a mod
      
      
      if(randomise==TRUE){
        # Generate a random vector of 0s (for no change) and -1s (for loci where the reference allele is to be switched)
        ran_vect = sample(c(0, -1), ncol(c_ind),  replace = T) 
        
        # Create a matrix with with as many rows as c_ind. 
        # Each row of this matrix should be made up of two times ran_vect (since we are working with allele counts, not frequencies). 
        # Because the same changes need to be applied to each individual
        
        ran_matrix = t(matrix(2*ran_vect, nrow = ncol(c_ind), ncol = nrow(c_ind)))
        
        # Calculate the allele counts of the new (randomised) reference alleles
        
        c_ind = abs(c_ind + ran_matrix)
        
      }
      
      
      
      ################################################################
      ######## Randomise the reference allele in pbar1 and pbar2 #####
      ################################################################
      
      # Randomly change the reference allele
      # This can be done as follows:
      # Add 0s to the frequencies of those alleles that stay the same, and -1 to those alleles that are to be switched
      # Then take a mod
      
      if(randomise==TRUE){
        
        # Create a matrix with with as many rows as c_ind. Each row of this matrix should be made up of ran_vect (computed while randomising c_ind). 
        # Because the same changes need to be applied to each individual
        # Note that ran_vect needs to be restricted to retained loci
        
        ran_matrix_pbar = t(matrix(ran_vect, nrow = ncol(pbar1), ncol = nrow(pbar1)))
        
        # Calculate the frequencies of the new (randomised) reference alleles
        
        pbar1 = abs(pbar1 + ran_matrix_pbar)
        pbar2 = abs(pbar2 + ran_matrix_pbar)
        
      }
      
      # Store the memory
      
      mem = cbind(mem, mem_used())
      
      # Garbage collection
      gc(verbose = FALSE)
      
      ##################################################
      ##################################################
      ######### Jarrod's code for analysis #############
      ##################################################
      ##################################################
      
      if(pdelta_method=="manual"){
      
      ### Fit the model serially varying pdelta, select the estimate that has the highest log likelihood
      
          LL<-vA_est_temp<-bdelta_intercept_temp<-bdelta_slope_temp<-bdelta_var_temp<-1:nseq # Creating empty vectors to store pdelta and estimated vA in each model
          
          
          for(i in 1:nseq){
            
            
            message("Saving a copy of the environment...")
            #save.image(file = paste(output_path, "/Output_temp", ".RData", sep ="")) # Save the output to investigate when things crash due to segfaults
            message("Performing analyses...")
            print(pdelta[i])
            
            m1<-Vw_model(C0 = c_ind/2,          # parental genotypes (rows individuals, columns loci, coded as 0, 1/2 or 1) 
                         nR = NRF,          # matrix of non-recombinant probabilities between loci
                         pbar1 = pbar1,       # vector of allele frequencies at time-point 1
                         ngen1=1,     # number of generations between parents and time-point 1
                         pbar2 = pbar2,       # vector of allele frequencies at time-point 2
                         ngen2 = ngen_expt + 1,       # number of generations between parents and time-point 2
                         nind = nrow(c_ind),        # population size in each replicate
                         proj=proj, # projection type for allele frequencies: "LoM", "BLoM", "L" or "N"
                         LDdelta = LDdelta,
                         pa = pa,
                         pdelta = pdelta[i],
                         bdelta = bdelta,
                         Vs = Vs,
                         method = method,
                         L = NULL,    # list with elements UL and DL
                         svdL = NULL,    # list with elements UL and DL
                         bigalgebra = bigalgebra, 
                         tol = sqrt(.Machine$double.eps))
            
            LL[i]<-m1$model$loglik
            vA_est_temp[i]<-m1$Vw_est
            bdelta_intercept_temp[i] = m1$bdelta[1]
            bdelta_slope_temp[i] = m1$bdelta[2]
            bdelta_var_temp[i] = m1$bdelta_var 
            message(paste("Finding the best pdelta...", round((i/nseq)*100), "% complete"))
          }
          
          vA_est[sim] = vA_est_temp[which(LL == max(LL))] # Store the estimate from the model with the highest log likelihood
          pdelta_est[sim] = pdelta[which(LL == max(LL))]
          bdelta_intercept_est[sim] = bdelta_intercept_temp[which(LL == max(LL))]
          bdelta_slope_est[sim] = bdelta_slope_temp[which(LL == max(LL))]
          bdelta_var_est[sim] = bdelta_var_temp[which(LL == max(LL))]
          plot(vA_est~vA_true, xlab = "True value of Vw", ylab = "Estimate of Vw")
          abline(0,1)
          mem = cbind(mem, mem_used()) # Store the memory usage
      
      }
      
      
      if(pdelta_method=="fixed"|pdelta_method=="optim"){
        
        message("Saving a copy of the environment...")
        #save.image(file = paste(output_path, "/Output_temp", ".RData", sep ="")) # Save the output to investigate when things crash due to segfaults
        message("Performing analyses...")
        m1<-Vw_model(C0 = c_ind/2,          # parental genotypes (rows individuals, columns loci, coded as 0, 1/2 or 1) 
                     nR = NRF,          # matrix of non-recombinant probabilities between loci
                     pbar1 = pbar1,       # vector of allele frequencies at time-point 1
                     ngen1=1,     # number of generations between parents and time-point 1
                     pbar2 = pbar2,       # vector of allele frequencies at time-point 2
                     ngen2 = ngen_expt + 1,       # number of generations between parents and time-point 2
                     nind = nrow(c_ind),        # population size in each replicate
                     proj=proj, # projection type for allele frequencies: "LoM", "BLoM", "L" or "N"
                     LDdelta = LDdelta,
                     pa = pa,
                     pdelta = pdelta,
                     bdelta = bdelta,
                     Vs = Vs,
                     method = method,
                     L = NULL,    # list with elements UL and DL
                     svdL = NULL,    # list with elements UL and DL
                     bigalgebra = bigalgebra, 
                     tol = sqrt(.Machine$double.eps))
        
        
        vA_est[sim] = m1$Vw_est # Store the estimate from the model with the highest log likelihood
        pdelta_est[sim] = m1$pdelta # The sample() functions ensures that only one value is selected in case there are multiple points with the highest LL
        pdelta_var_est[sim] = m1$pdelta_var
        bdelta_intercept_est[sim] = m1$bdelta[1]
        bdelta_slope_est[sim] = m1$bdelta[2]
        bdelta_var_est[sim] = m1$bdelta_var
        plot(vA_est~vA_true, xlab = "True value of Vw", ylab = "Estimate of Vw")
        abline(0,1)
        
        mem = cbind(mem, mem_used()) # Store the memory usage
        
      }
      
      rm(list = c("c_ind", "NRF")) # Remove memory-heavy objects before the next simulation starts 
      # Garbage collection
      gc(verbose = FALSE)
  
  }    
   
  
  ########################################################
  ######### Save simulation data in a spreadsheet ########
  ########################################################
  
  if(record == TRUE){
  dat = read.csv(paste(output_path, "/Data.csv", sep = ""), header=FALSE)
  dat = rbind(dat, c(Set_ID, as.character(Sys.time()), end_gen, ngen_expt, Ne, n_ind_exp, n_cages, sequence_length, r_msp, r, r_expt, mu_msp, mu, mu_neutral, shape, scale, mut_ratio, proj, LDdelta, pa, Vs, randomise, pdelta_method, bdelta_method, vA_true[sim], vA_est[sim], pdelta_est[sim], pdelta_var_est[sim], bdelta_intercept_est[sim], bdelta_slope_est[sim], seg_sites[sim], bdelta_var_est[sim], va_lost[sim]))
  write.table(dat, file = paste(output_path, "/Data.csv", sep = ""),col.names = FALSE, row.names = FALSE, sep = ",")
  }
  
  
}

pdf(paste(output_path, "/Output_",gsub(" ", "_", Sys.time()), ".pdf", sep = ""), onefile = F)

plot(vA_est~vA_true, xlab = "True value of Vw", ylab = "Estimate of Vw")
abline(0,1)

dev.off()

#save.image(file = paste(output_path, "/output", gsub(" ", "_", Sys.time()), ".RData", sep =""))

