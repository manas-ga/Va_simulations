rm(list = ls())
# source("C:/Academics/Post-doc/Va_simulations/5_History_sim/00_History_sim_JARROD.R") ## Local windows

# source("/mnt/c/Academics/Post-doc/Va_simulations/5_History_sim/00_History_sim_JARROD.R") ## Local Wsl

# source("/data/home/msamant/Manas/Va_simulations/5_History_sim/00_History_sim_JARROD.R")  ## ON VERA


####################################
######### Packages #################
####################################

#library(matlib)
library(MCMCglmm)
library(asreml)
library(Matrix)
library(rmutil)
#library(lme4)

########################################################################
########### paths of various scripts and functions #####################
########################################################################


### Base path and path to Vw.Rmd (file containing Jarrod's functions) (depending on the system) ###

if(Sys.info()["nodename"]=="vera.bio.ed.ac.uk"){
  
  base_path = "/data/home/msamant/Manas/Va_simulations/5_History_sim" ## ON VERA
  Vw_path = "/data/home/msamant/Manas/Va_simulations/5_History_sim/Vw.Rmd"  ### Jarrod's functions and other code is stored here
  
  
}else{
  
  if(Sys.info()["sysname"]=="Linux"){
    
    base_path = "/mnt/c/Academics/Post-doc/Va_simulations/5_History_sim" ## Local Wsl
    #Vw_path = "/mnt/c/Users/msamant/Documents/GitHub/Va_simulations/6_Code_test/Vw.Rmd" ### Jarrod's functions and other code is stored here
    Vw_path = "/mnt/c/Academics/Post-doc/Va_simulations/5_History_sim/Vw.Rmd" # Jarrod's code from 4 Dec 2023
    
  }else{
    
    base_path = "C:/Academics/Post-doc/Va_simulations/5_History_sim" ## Local windows
    Vw_path = "C:/Users/msamant/Documents/GitHub/Va_simulations/6_Code_test/Vw.Rmd" ### Jarrod's functions and other code is stored here
    
  }
  
}


msprime_path = file.path(base_path, "0_neutral_burnin.py")                                                    ## msprime script generating the initial sequences
slim_history_path = file.path(base_path, "1_History.slim")                                                    ## SLiM script running the history
msprime_add_neutral_path = file.path(base_path, "1_History_add_neutral_mut.py")                               ## Path to the msprime script that adds neutral mutations to the tree sequence generated by 1_History.slim
slim_expt_path = file.path(base_path, "4_Experiment.slim")                                                    ## SLiM script running the experiment
extract_genomes_path = file.path(base_path, "3_Extract_genomes.py")                                           ## Python script extracting mutations and genomes from the SLiM output for gen1
extract_mut_path = file.path(base_path, "2_Extract_mutations.py")                                             ## Python script extracting mutations for the experimental generations

msprime_output_path = paste(base_path, "/b_Interim_files/Msprime_outputs", sep = "")                          ## Directory for outputs generated by msprime
slim_output_path = paste(base_path, "/b_Interim_files/SLiM_outputs", sep = "")                                ## Path where SLiM output files are stored
mutations_path = paste(base_path, "/b_Interim_files/Mutations", sep = "")                                     ## Path for text file containing mutations generated by the python script  
c_matrix_path = paste(base_path, "/b_Interim_files/C_Matrices", sep = "")                                     ## .csv file storing c matrix generated by the python script
rdata_path = paste(base_path, "/b_Interim_files/Rdata", sep = "")
output_path = paste(base_path, "/c_Output", sep = "")


###################################
###### Create file structure ######
###################################

##### Create directory that stores outputs
system(paste("mkdir -p", output_path)) # Make directory but ignore if already present

##### Create directory that stores temp files and directories therein
system(paste("mkdir -p", paste(base_path, "/b_Interim_files", sep = "")))
system(paste("rm -rf", paste(base_path, "/b_Interim_files/*", sep = ""))) # Remove the contents of this directory

system(paste("mkdir -p", paste(base_path, "/b_Interim_files/C_Matrices", sep = ""))) 
system(paste("mkdir -p", paste(base_path, "/b_Interim_files/Genomes", sep = ""))) # Not needed
system(paste("mkdir -p", paste(base_path, "/b_Interim_files/Msprime_outputs", sep = "")))
system(paste("mkdir -p", paste(base_path, "/b_Interim_files/Mutations", sep = "")))
system(paste("mkdir -p", paste(base_path, "/b_Interim_files/Rdata", sep = ""))) ## Not really needed
system(paste("mkdir -p", paste(base_path, "/b_Interim_files/SLiM_outputs", sep = "")))



#################################
#### Load Jarrod's functions ####
#################################

functions_only=TRUE ## Read only the functions

rmarkdown::render(file.path(Vw_path))


#####################################################
############ Simulation Parameters ##################
#####################################################

nsims = 5                             # Number of simulations (change scale in each simulation)
n_cages = 10                           # The number of replicate cages in the experiment
start_gen = 1                          # 
end_gen = 2                            # How many generations should the SLiM simulation run for while simulating the history (burnin)
output_freq = 500                      # The frequency with which SLiM outputs are to be generated for the analysis of history (optional)
ngen_expt = 3                          # How many generations should allele frequency changes be calculated over in the experiment

list_gen = seq(1,end_gen, output_freq) # List of generations for which measurements are to be made in the analysis of history
history_test = F # Plot population parameters during the history?

Ne = 1e+06                             # Effective population size
n_ind = 10000                          # Number of individuals to be sampled in msprime and then run forward in SLiM
n_ind_exp = 1000                       # The population size of the experiment. In 00_History.slim the population reduces to n_ind_exp in the last generation to simulate the sampling of the parents for the experiment
n_sample = 1000                        # Number of individuals to be sampled to construct the c matrix  (This is just because c matrices become awfully large). Typically should be the same as n_ind_exp 

sequence_length = 1e+05                # Just have a single continuous chromosome that is simulated
r = 1.4e-06                            # Recombination rate (per site per generation)
r_expt = 1.4e-05                       # Unscaled recombination rate to be used during during the experiment (1.4e-08)
r_msp = 1.4e-08                        # Recombination rate for msprime
AtleastOneRecomb = F                   # Whether there has to be at least one recombination event
#mu = 1.8e-06                           # Mutation rate during the forward simulation of the history

mu_list = seq(1.3e-06, 1.3e-06, length = nsims) # If mu is to be varied in order to vary true Vw
mu_neutral = 0                   # Mutation rate of neutral mutations to be back-simulated using msprime on the tree sequence generated by the forward slim simulation

mu_msp = 1.3e-9                        # A separate mutation rate for the msprime simulation
mu_expt = 0                            # Mutation rate during the experiment


##############################
### DFE-related parameters ###
##############################

DFE = "n"                              # DFE can be "g" (gamma) or "n" (normal) 

# If DFE is "g"
shape = 0.2                            # Shape of the gamma DFE ##### mean = shape*scale
scale_list = seq(0.15, 0.15, length = nsims) # Vector of Scale of the gamma DFE
mut_ratio = 0.00                       # The ratio of beneficial:deleterious mutations in msprime

# If DFE is "n" need to specify the mean and the variance of the normal distribution
mean_alpha = 0
var_alpha_list = seq(0.00001, 0.00018, length = nsims) # Vector to store variance of normal DFE

############################################################################################
######## Analysis parameters can be found as arguments of the function Vw_model ############
############################################################################################

proj="BLoM" # projection type for allele frequencies: "LoM", "BLoM", "L" or "N"
LDdelta = TRUE
pa = 1
Vs = "LoNL"
method="REML"
randomise = F # Should the reference allele be randomised for analysis?

# How is pdelta to be estimated? 
# Can be "optim" (using the function optim()), or "fixed" or "manual"(estimated by manually scanning a range of pdelta values)

pdelta_method = "fixed" # "optim" or "manual" or "fixed"

if(pdelta_method=="fixed"){
  pdelta = 0 # Can be specified to any value
}

if(pdelta_method=="optim"){
  pdelta = NA # This triggers the use of optim() inside the function Vw_model()
}

if(pdelta_method=="manual"){
  
  nseq<-15 # The number of times pdelta is to be varied 
  pdelta_l = -2.5 # Lower limit of pdelta
  pdelta_u = 0.5 # Upper limit of pdelta
  pdelta<-seq(pdelta_l, pdelta_u, length=nseq)
  
}

# How should bdelta[1] (intercept) and bdelta[2] (slope of (p-q)) be estimated

bdelta_method = "estimated" # Can be "fixed" or "estimate"

if(bdelta_method=="estimate"){
  bdelta = c(NA, 0)
}else{
  bdelta = c(NA, 0) # This only estimates the slope while keeping the intercept fixed at 0
}


####################################################################################################################################################


# Create empty vectors to store true vA and estimates of vA from the model

vA_true = rep(NA, nsims) # Additive genetic variance
va_true = rep(NA, nsims) # Additive genic variance
vA_est = rep(NA, nsims)  # Estimated vA from the model
pdelta_est = rep(NA, nsims) # pdelta is estimated in each simulation with the help of maximum likelihood (implemented manually)
seg_sites = rep(NA, nsims) # Number of segregating sites at the beginning of the experiment in each simulation

for (sim in 1:nsims){
  
    # Specify the scale of the the gamma distribution or the variance of the normal distribution of selection coefficients
  
    scale = scale_list[sim] 
    var_alpha = var_alpha_list[sim]
    
    # Specify the mutation rate
    mu = mu_list[sim]
    
    message(paste("Simulation", sim, "in progress..."))
  


    #####################################################
    ############# Run msprime (neutral burnin) ##########
    #####################################################
    
    message("Running msprime...")
    
    system(paste("python", msprime_path, Ne, n_ind, sequence_length, r_msp, mu_msp, shape, scale, msprime_output_path, mut_ratio, DFE, mean_alpha, sqrt(var_alpha), sim))
    
    ###############################################################
    ################# Simulate the history in SLim ################
    ###############################################################
    
    message("Forward simulating the history using SLiM...")
    
    ### This has lot's of command line arguments. Creating separate strings for each argument
    
    arg1 = paste("-d mu=", mu, sep = "")
    arg2 = paste("-d shape=", shape, sep = "")
    arg3 = paste("-d scale=", scale, sep = "")
    arg4 = paste("-d sequence_length=", sequence_length, sep = "")
    arg5 = paste("-d r=", r, sep = "")
    
    #arg6 = paste("-d msprime_output_path=","'", msprime_output_path, "'", sep = "") # Only works on Windows
    #arg7 = paste("-d slim_output_path=", "'", slim_output_path, "'", sep = "") # Only works on Windows
    
    arg6 = paste("-d ", shQuote(paste("msprime_output_path=","'", msprime_output_path, "'", sep = "")), sep = "")
    arg7 = paste("-d ", shQuote(paste("slim_output_path=","'", slim_output_path, "'", sep = "")), sep = "") 
    
    arg8 = paste("-d end_gen=", end_gen, sep = "")
    arg9 = paste("-d output_freq=", output_freq, sep = "")
    arg10 = paste("-d mut_ratio=", mut_ratio, sep = "")
    arg11 = paste("-d n_ind_exp=", n_ind_exp, sep = "") # The population size is to be reduced to n_ind_exp in generation end_gen (to simulate sampling of the parents for the experiment)
    arg12 = paste("-d ", shQuote(paste("DFE=", "'", DFE, "'", sep = "")), sep = "")
    arg13 = paste("-d mean_alpha=", mean_alpha, sep = "")
    arg14 = paste("-d var_alpha=", var_alpha, sep = "")
    arg15 = paste("-d simulation=", sim, sep = "")
    
    system(paste("slim", arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, slim_history_path))
    #system(paste("slim", arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11,  slim_history_path))
    
    ###################################################################
    ############### Add neutral mutations using msprime ###############
    ###################################################################
    
    message("Adding neutral mutations...")
    
    system(paste("python", msprime_add_neutral_path, msprime_output_path, slim_output_path, mu_neutral, sim))
    
    
    ###################################################
    ######### Simulate the experiment in SLiM #########
    ###################################################
    
    message("Forward simulating the experiment using SLiM...")
    
    ### Loop over the cage replicates
    
    for (cage in (1:n_cages)){
      
      message(paste("Cage", cage, "of simulation", sim, "in progress..."))
      
      
      ### This has lot's of command line arguments. Creating separate strings for each argument
      
      expt_arg1 = paste("-d mu=", mu_expt, sep = "")
      expt_arg2 = paste("-d shape=", shape, sep = "")
      expt_arg3 = paste("-d scale=", scale, sep = "")
      expt_arg4 = paste("-d sequence_length=", sequence_length, sep = "")
      expt_arg5 = paste("-d r=", r_expt, sep = "")
      expt_arg6 = paste("-d ", shQuote(paste("msprime_output_path=","'", msprime_output_path, "'", sep = "")), sep = "") 
      expt_arg6a = paste("-d ", shQuote(paste("slim_output_path=","'", slim_output_path, "'", sep = "")), sep = "") 
      expt_arg7 = paste("-d mut_ratio=", mut_ratio, sep = "")
      expt_arg8 = paste("-d end_gen=", end_gen, sep = "")
      expt_arg9 = paste("-d ", shQuote(paste("DFE=", "'", DFE, "'", sep = "")), sep = "")
      expt_arg10 = paste("-d mean_alpha=", mean_alpha, sep = "")
      expt_arg11 = paste("-d var_alpha=", var_alpha, sep = "")
      expt_arg12 = paste("-d ngen_expt=", ngen_expt, sep = "")
      expt_arg13 = paste("-d simulation=", sim, sep = "")
      expt_arg14 = paste("-d cage=", cage, sep = "")
      
      system(paste("slim", expt_arg1, expt_arg2, expt_arg3, expt_arg4, expt_arg5, expt_arg6, expt_arg6a, expt_arg7, expt_arg8, expt_arg9, expt_arg10, expt_arg11, expt_arg12, expt_arg13, expt_arg14, slim_expt_path))
      
    }
    
    ##################################################################################
    ##################################################################################
    ########                 Analysis of the parents' generation               #######
    ######## Calculate c matrix, L, true Vw, and the non-recombination matrix  #######
    ##################################################################################
    ##################################################################################
    
    
    message("Reading the state of the population in the parent's generation...")
    
    system(paste("python", 
                 extract_genomes_path,                                                      # Path of the python script (3_Extract_genomes.py)
                 paste(slim_output_path, "/sim", sim, "_output_parents.txt", sep = ""),     # Path of the .txt file containing the SLiM output for the parent's generation (sys.argv[1])
                 paste(mutations_path, "/mutations_parents.txt", sep = ""),                 # Path of the .txt output file containing the mutations in the parents' generation (sys.argv[2])
                 paste(c_matrix_path, "/c_matrix_parents.csv", sep = ""),                   # Path of the .csv output file containing the c matrix for genomes in the parents' generation (sys.argv[3])
                 n_sample))                                                                 # Number of individuals to be sampled randomly to construct the c matrix (just for space issues). Typically should be set to same as n_ind_exp
    
    # Read genomes
    c_genome = read.csv(paste(c_matrix_path, "/c_matrix_parents.csv", sep =""), header=F) # as.integer done to avoid scientific notation
    
    c_genome = as.matrix(c_genome)
    
    # Convert genome data into individual data (rows are individuals and columns are allele counts {0,1 or 2} at various sites). 
    # Note that genome 1 and genome 2 are from individual 1, and so on
    
    message("Calculating the C matrix for the parents' generation...")
    
    n_individuals = nrow(c_genome)/2
    n_sites = ncol(c_genome)
    
    c_ind = c_genome[seq(1, 2*n_individuals, 2),] + c_genome[seq(2, 2*n_individuals, 2),]
    
    
    #### Calculate the matrix of second mixed moments of c, ie. the L matrix
    
    message("Calculating the L matrix for the parents' generation...")
    
    L = cov(c_ind/2) 
    
    ####### Notice that L has some 0s on the diagonal
    # This happens only if one samples individuals from the parents' generation while building the c matrix (i.e. when sample_size is less than n_ind_exp); the sample may not contain some low frequency mutations, i.e. some loci are not segregating in the sample, but are in the parents' population
    
    # identify the loci that are missing in the sample
    
    missing_loci = which(diag(L)==0)
    retained_loci = which(diag(L)!=0)
    
    # Trim L to contain only the retained loci
    
    L_ret = L[retained_loci,retained_loci]
    
    # Trim the c matrix to contain only the retained loci, i.e. the loci that are segregating in the sample
    
    c_ind_ret = c_ind[,retained_loci]
    

    ## Read the list of mutations output generated by SLiM and subsequently cropped out as a separate file by Python (for the parents' generation)
    
    mutations_0 = read.table(paste(mutations_path, "/mutations_parents.txt", sep = ""), header=T, sep = " ")
    
    # Sort mutations based on the Temp_ID, so that the order of loci matches the order in the C and L matrices
    
    mutations_0 = mutations_0[order(mutations_0$Temp_ID),]
    
    # Trim mutations to contain only the retained loci, i.e. the loci that are segregating in the sample
    
    mutations_ret = mutations_0[retained_loci,]
    
    # Calculate the number of loci that are retained
    
    n_sites_ret = ncol(c_ind_ret)
    seg_sites[sim] = n_sites_ret
    
    
    ### Calculate true vA (additive genetic variance) and va (additive genic variance) 
    
    message("Computing the true Vw in the parents' generation...")
    
    
    list_alpha = 2*(mutations_ret$s)
    
    vA_true[sim] = t(list_alpha)%*%L_ret%*%list_alpha         # Additive genetic variance
    va_true[sim] = sum(diag(L_ret)*list_alpha*list_alpha)     # Additive genic variance
    
      
    message("Calculating the the matrix of non-recombinant fractions for the parents' generation...")
    
    #dist = matrix(0, nrow(L_ret), nrow(L_ret)) # Matrix of paired distances
    
    #### Loop through columns 
    
    #for (site in 1:nrow(L_ret)){
    #  dist[, site] = abs(mutations_ret$Position - mutations_ret$Position[site])
    #}
    
    #NRF = 1 - 0.5*(1 - exp(-2*dist*r_expt))
    
    # Calculate the non-recombinant fraction using Jarrod's function
    
    NRF = form_nR(mutations_ret$Position, r_expt, sequence_length, AtleastOneRecomb)
    
    message(paste("There are", nrow(L_ret), "Segregating sites in the parents' generation..."))
    message(paste(" The tru Vw in the parents' generation is", vA_true[sim]))
    
    
    
    ############################################################################
    ############################################################################
    ####### Calculate allele frequencies in the experiment for each cage #######
    ############################################################################
    ############################################################################  
    
    # Create empty vector to create the data frame containing the following variables as columns:
    # 1. Raw delta P
    # 2. Projected delta P
    # 3. Cage ID (replicate)
    # 4. Locus ID
    
    d_proj = c()
    d_raw = c()
    P_matrix = c()  
    
    for (cage in (1:n_cages)){
      
      ###############################
      ###### extract mutations ######
      ###############################
      
      
      # There are two command line arguments (1. Path of the SLiM output file, 2. Path where mutations are to be written) 
      
      
      message(paste("Extracting mutations in cage ", cage, "...", sep = ""))
      
      for (gen in (end_gen + 1):(end_gen + 1 + ngen_expt)){
        #message(paste((gen-end_gen)*100/5, "% extracted..."))
        system(paste("python", 
                     extract_mut_path, 
                     paste(slim_output_path, "/sim", sim, "_cage", cage, "_output_experiment_", as.integer(gen), ".txt", sep = ""), 
                     paste(mutations_path, "/mutations_", as.integer(gen), ".txt", sep = ""))) # as.integer done to avoid scientific notation
      }
      
      
    
      
      ### Create an empty matrix to store allelic frequencies in each generation
      
      # If some of the loci get fixed/lost in subsequent generations, NAs should be inserted
      
      message("Storing allele frequencies...")
      
      # Create an empty vector to store allele frequencies
      
      P = c()
      
      
      # store the frequencies in the parent's generation in P
      # Frequency = (Number of genomes)/(2*popsize)
      
      P = cbind(P, mutations_ret$Number/(2*n_ind_exp))
      
      
      
      ### Loop through the generations of the experiment identifying mutations that were present in the parents' generation (using permanent IDs) and recording their frequencies
      
      for (gen in (end_gen+1):(end_gen+ngen_expt+1)){
        
        # Read the file storing mutation information
        mut = read.csv(paste(mutations_path ,"/Mutations_", as.integer(gen), ".txt", sep = ""), sep = " ") # as.integer gets rid of scientific notation
        
        # Sort mutations based on the Temp_ID, so that the order of loci matches the order in the C and L matrices
        
        mut = mut[order(mut$Temp_ID),]
        
        # Create an empty vector to store frequencies of mutations in the current generation
        freq = c()
        
        # Loop through the permanent IDs of  mutations segregating in end_gen (parents' generation)
        # i.e. Loop through Permanent IDs in mutations_1
        # Check if each mutation is present in the current generation
        # If present, record the frequency in freq, otherwise add either 0 or 1 to freq using the round() function
        
        for(mutation in mutations_ret$Permanent_ID){
          if(mutation %in% mut$Permanent_ID){freq = rbind(freq, (mut[which(mut$Permanent_ID==mutation),]$Number)/(2*n_ind_exp))
          }else{
            freq = rbind(freq, round(P[which(mutations_ret$Permanent_ID==mutation), gen - end_gen]))
            #print(round(P[which(mutations_1$Permanent_ID==mutation), gen -1]))
          }
        }
        
        # Add the vector freq to P
        
        P = cbind(P, freq)
        #print(paste(round((gen-start_gen)*100/(end_gen-start_gen), 2), " % complete!"))
        
      }
     
      P_matrix = rbind(P_matrix, P)
      
    }
    
    
    ##### Calculate matrices of allele frequencies with rows as replicates ######
    
    pbar1 = matrix(NA, nrow = n_cages, ncol = n_sites)
    pbar2 = matrix(NA, nrow = n_cages, ncol = n_sites)
    for (i in 1:n_cages){
      pbar1[i,] = P_matrix[((i-1)*n_sites + 1):((i-1)*n_sites + n_sites),2] ## Matrix of frequencies at the start of the experiment (ie F1 generation)
    }
    
    for (i in 1:n_cages){
      pbar2[i,] = P_matrix[((i-1)*n_sites + 1):((i-1)*n_sites + n_sites),ngen_expt + 2] ## Matrix of frequencies at the end of the experiment
      
      
    }
    
    ################################################################
    ######## Randomise the reference allele in the c matrix ########
    ################################################################
    
    # Randomly change the reference allele
    # This can be done as follows:
    # Add 0s to the allele counts of those alleles that stay the same, and -2 to those alleles that are to be switched
    # Then take a mod
    
    
    if(randomise==T){
      # Generate a random vector of 0s (for no change) and -1s (for loci where the reference allele is to be switched)
      ran_vect = sample(c(0, -1), ncol(c_ind_ret),  replace = T) 
      
      # Create a matrix with with as many rows as c_ind_ret. 
      # Each row of this matrix should be made up of two times ran_vect (since we are working with allele counts, not frequencies). 
      # Because the same changes need to be applied to each individual
      
      ran_matrix = t(matrix(2*ran_vect, nrow = ncol(c_ind_ret), ncol = nrow(c_ind_ret)))
      
      # Calculate the allele counts of the new (randomised) reference alleles
      
      c_ind_ret = abs(c_ind_ret + ran_matrix)
      
    }
    
    
    
    ################################################################
    ######## Randomise the reference allele in pbar1 and pbar2 #####
    ################################################################
    
    # Randomly change the reference allele
    # This can be done as follows:
    # Add 0s to the frequencies of those alleles that stay the same, and -1 to those alleles that are to be switched
    # Then take a mod
    
    if(randomise==T){
      
      # Create a matrix with with as many rows as c_ind. Each row of this matrix should be made up of ran_vect (computed while randomising c_ind). 
      # Because the same changes need to be applied to each individual
      # Note that ran_vect needs to be restricted to retained loci
      
      ran_matrix_pbar = t(matrix(ran_vect, nrow = ncol(pbar1), ncol = nrow(pbar1)))
      
      # Calculate the frequencies of the new (randomised) reference alleles
      
      pbar1 = abs(pbar1 + ran_matrix_pbar)
      pbar2 = abs(pbar2 + ran_matrix_pbar)
      
    }
    
    ##################################################
    ##################################################
    ######### Jarrod's code for analysis #############
    ##################################################
    ##################################################
    
    
    message("Fitting the model...")
    
    if(pdelta_method=="manual"){
    
    ### Fit the model varying pdelta, select the estimate that has the highest log likelihood
    
        LL<-vA_est_temp<-1:nseq # Creating empty vectors to store pdelta and estimated vA in each model
        
        
        for(i in 1:nseq){
          
          save.image(file = paste(output_path, "/Output_temp", ".RData", sep ="")) # Save the output to investigate when things crash due to segfaults
          m1<-Vw_model(C0 = c_ind_ret/2,          # parental genotypes (rows individuals, columns loci, coded as 0, 1/2 or 1) 
                       nR = NRF,          # matrix of non-recombinant probabilities between loci
                       pbar1 = pbar1,       # vector of allele frequencies at time-point 1
                       ngen1=1,     # number of generations between parents and time-point 1
                       pbar2 = pbar2,       # vector of allele frequencies at time-point 2
                       ngen2 = ngen_expt + 1,       # number of generations between parents and time-point 2
                       nind = nrow(c_ind_ret),        # population size in each replicate
                       proj="BLoM", # projection type for allele frequencies: "LoM", "BLoM", "L" or "N"
                       LDdelta = TRUE,
                       pa = pa,
                       pdelta = pdelta[i],
                       Vs = Vs,
                       method = method,
                       L = NULL,    # list with elements UL and DL
                       svdL = NULL,    # list with elements UL and DL
                       tol = sqrt(.Machine$double.eps))
          
          LL[i]<-m1$model$loglik
          vA_est_temp[i]<-m1$Vw_est
          message(paste("Finding the best pdelta...", round((i/nseq)*100), "% complete"))
        }
        
        vA_est[sim] = vA_est_temp[which(LL == max(LL))] # Store the estimate from the model with the highest log likelihood
        pdelta_est[sim] = pdelta[which(LL == max(LL))]
        plot(vA_est~vA_true, xlab = "True value of Vw", ylab = "Estimate of Vw")
        abline(0,1)
    
    }
    
    
    if(pdelta_method=="fixed"|pdelta_method=="optim"){
      
      
      m1<-Vw_model(C0 = c_ind_ret/2,          # parental genotypes (rows individuals, columns loci, coded as 0, 1/2 or 1) 
                   nR = NRF,          # matrix of non-recombinant probabilities between loci
                   pbar1 = pbar1,       # vector of allele frequencies at time-point 1
                   ngen1=1,     # number of generations between parents and time-point 1
                   pbar2 = pbar2,       # vector of allele frequencies at time-point 2
                   ngen2 = ngen_expt + 1,       # number of generations between parents and time-point 2
                   nind = nrow(c_ind_ret),        # population size in each replicate
                   proj="BLoM", # projection type for allele frequencies: "LoM", "BLoM", "L" or "N"
                   LDdelta = TRUE,
                   pa = pa,
                   pdelta = pdelta,
                   Vs = Vs,
                   method = method,
                   L = NULL,    # list with elements UL and DL
                   svdL = NULL,    # list with elements UL and DL
                   tol = sqrt(.Machine$double.eps))
      
      
      vA_est[sim] = m1$Vw_est # Store the estimate from the model with the highest log likelihood
      pdelta_est[sim] = m1$pdelta # The sample() functions ensures that only one value is selected in case there are multiple points with the highest LL
      plot(vA_est~vA_true, xlab = "True value of Vw", ylab = "Estimate of Vw")
      abline(0,1)
      
    }
    

    
    
}


#save.image(file = paste(output_path, "/output", gsub(" ", "_", Sys.time()), ".RData", sep =""))

pdf(paste(output_path, "/Output_",gsub(" ", "_", Sys.time()), ".pdf", sep = ""), onefile = F)

plot(vA_est~vA_true, xlab = "True value of Vw", ylab = "Estimate of Vw")
abline(0,1)

dev.off()