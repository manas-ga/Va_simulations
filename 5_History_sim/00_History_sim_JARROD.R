rm(list = ls())

# source("C:/Users/msamant/Documents/GitHub/Va_simulations/5_History_sim/00_History_sim_JARROD.R") ## Local windows

# source("/mnt/c/Users/msamant/Documents/GitHub/Va_simulations/5_History_sim/00_History_sim_JARROD.R") ## Local Wsl

# source("/data/home/msamant/Manas/Va_simulations/Github/Va_simulations/5_History_sim/00_History_sim_JARROD.R")  ## ON VERA

# source("/ceph/users/marun/Va_simulations/5_History_sim/00_History_sim_JARROD.R")  ## ON QMASTER


##########################################
######## Code parallelization ############
##########################################

# parallel -j 18 --colsep "\s" --delay 5.0 Rscript 00_History_sim_JARROD.R :::: 000_parameter_grid.txt
# https://www.danielecook.com/using-gnu-parallel-for-bioinformatics/

########################################################################
########### paths of various scripts and functions #####################
########################################################################


### Base path and path to Vw.Rmd (file containing Jarrod's functions) (depending on the system) ###

if(Sys.info()["nodename"]%in%c("bigfoot", "bigshot", "bigbird", "bigyin", "biggar", "bigwig", "c1", "c2", "c3", "c4", "c5", "c6")){
  
  base_path = "/ceph/users/marun/Va_simulations/5_History_sim"
  Vw_path = "/ceph/users/marun/Va_simulations/6_Code_Test/Vw.Rmd"
  
}else{
  
  
  if(Sys.info()["nodename"]=="vera.bio.ed.ac.uk"){
    
    base_path = "/data/home/msamant/Manas/Va_simulations/Github/Va_simulations/5_History_sim" ## ON VERA
    Vw_path = "/data/home/msamant/Manas/Va_simulations/Github/Va_simulations/6_Code_Test/Vw.Rmd"  ### Jarrod's functions and other code is stored here
    
    
  }else{
    
    if(Sys.info()["sysname"]=="Linux"){
      
      base_path = "/mnt/c/Users/msamant/Documents/GitHub/Va_simulations/5_History_sim" ## Local Wsl
      Vw_path = "/mnt/c/Users/msamant/Documents/GitHub/Va_simulations/6_Code_test/Vw.Rmd" ### Jarrod's functions and other code is stored here
      
    }else{
      
      base_path = "C:/Users/msamant/Documents/GitHub/Va_simulations/5_History_sim" ## Local windows
      Vw_path = "C:/Users/msamant/Documents/GitHub/Va_simulations/6_Code_test/Vw.Rmd" ### Jarrod's functions and other code is stored here
      
    }
    
  }
  
  
}


# Paths to various scripts that are used for running the simulations and extracting information from SLiM outputs

msprime_burnin_path = file.path(base_path, "0_neutral_burnin.py")                                             ## msprime script generating the initial sequences
slim_history_path = file.path(base_path, "1_History.slim")                                                    ## SLiM script running the history
msprime_add_neutral_path = file.path(base_path, "1_History_add_neutral_mut.py")                               ## msprime script that adds neutral mutations to the tree sequence generated by 1_History.slim
slim_expt_path = file.path(base_path, "4_Experiment.slim")                                                    ## SLiM script running the experiment
extract_genomes_path = file.path(base_path, "3_Extract_genomes.py")                                           ## Python script extracting mutations and genomes from the SLiM output file 
extract_mut_path = file.path(base_path, "2_Extract_mutations.py")                                             ## Python script extracting mutations from the SliM output file

# Paths to various temporary directories

slim_output_path = paste(base_path, "/b_Interim_files/SLiM_outputs", sep = "")                                ## Path where SLiM and msprime output files are stored
mutations_path = paste(base_path, "/b_Interim_files/Mutations", sep = "")                                     ## Path for text file containing mutations generated by the python script  
c_matrix_path = paste(base_path, "/b_Interim_files/C_matrices", sep = "")                                     ## .csv file storing c matrix generated by the python script
output_path = paste(base_path, "/c_Output", sep = "")


###################################
###### Create file structure ######
###################################

##### Create directory that stores outputs
system(paste("mkdir -p", output_path)) # Make directory but ignore if already present

##### Create directory that stores temp files and directories therein
system(paste("mkdir -p", paste(base_path, "/b_Interim_files", sep = "")))
#system(paste("rm -rf", paste(base_path, "/b_Interim_files/*", sep = ""))) # Remove the contents of this directory

system(paste("mkdir -p", paste(base_path, "/b_Interim_files/C_matrices", sep = ""))) 
system(paste("mkdir -p", paste(base_path, "/b_Interim_files/Mutations", sep = "")))
system(paste("mkdir -p", paste(base_path, "/b_Interim_files/SLiM_outputs", sep = "")))


##### Create a spreadsheet to store cumulative data across all simulations (only if it doesn't exist already)

# Assign a "Set_ID" to each set of simulations 
# The set ID is the name of the system + time at which this script starts running. It stays constant throughout (for all the simulations run in that particular set).

Set_ID = as.character(paste(Sys.info()["nodename"], Sys.time()))
Set_ID = gsub(" ", "_", Set_ID)
Set_ID = paste(Set_ID, commandArgs(trailingOnly = TRUE)[1], commandArgs(trailingOnly = TRUE)[2], commandArgs(trailingOnly = TRUE)[3], commandArgs(trailingOnly = TRUE)[4], commandArgs(trailingOnly = TRUE)[5], commandArgs(trailingOnly = TRUE)[6], sep = "_")


if(!file.exists(paste(output_path, "/", Set_ID, "_Data.csv", sep = ""))){
  col_names = as.matrix(t(c("Set_ID","Time","end_gen", "ngen_expt", "Ne", "n_ind_exp", "n_cages", "sequence_length", "r_msp", "r", "r_expt", "mu_msp", "mu", "mu_neutral", "shape", "scale", "mut_ratio", "proj", "LDdelta", "pa", "Vs", "randomise", "pdelta_method", "bdelta_method", "va_true", "vA_true", "vA_est", "vA_left", "pdelta_emp", "bdelta_intercept_emp", "bdelta_slope_emp", "sigma2delta_emp", "pdelta_est", "pdelta_var_est", "bdelta_intercept_est", "bdelta_slope_est", "bdelta_var_est", "sigma2delta_est", "seg_sites", "seg_sites_neu", "seg_sites_ben", "seg_sites_del", "s_pmq")))
  write.table(col_names, file = paste(output_path, "/", Set_ID, "_Data.csv", sep = ""),col.names = FALSE, row.names = FALSE, sep = ",")
}


####################################
######### Packages #################
####################################

library(MCMCglmm)
library(asreml)
library(Matrix)
library(rmutil)
library(pryr) ## For tracking memory usage using mem_used()
library(bigalgebra)

#################################
#### Load Jarrod's functions ####
#################################

functions_only=TRUE ## Read only the functions

rmarkdown::render(file.path(Vw_path))

#####################################################
############ Simulation Parameters ##################
#####################################################

# Print command line arguments to screen
print(c("Mutation rate", "recombination rate (M)", "Population size", "No. of cages", "Experimental generations" ))
print(commandArgs(trailingOnly = TRUE))

simulate = TRUE                        # To run the simulation or not
analyse = TRUE                         # To perform the analysis on simulated data or not
record = TRUE                         # Should the data of the simulations be appended to "data.csv" 

nsims = 1                              # Number of simulations (change scale in each simulation)
n_cages = (as.numeric(commandArgs(trailingOnly = TRUE)[5]))                           # The number of replicate cages in the experiment
start_gen = 1                          # 
end_gen = 20000                            # How many generations should the SLiM simulation run for while simulating the history (burnin)
output_freq = 2500                     # The frequency with which SLiM outputs are to be generated for the analysis of history 
ngen_expt = (as.numeric(commandArgs(trailingOnly = TRUE)[6]))                          # How many generations should allele frequency changes be calculated over in the experiment


###########################################
########### Pop gen parameters ############
###########################################

Ne = 1.33e+06                          # Effective population size
n_ind = 2500                           # Number of individuals to be sampled in msprime and then run forward in SLiM
n_ind_exp = (as.numeric(commandArgs(trailingOnly = TRUE)[4]))                       # The population size of the experiment. In 00_History.slim the population reduces to n_ind_exp in the last generation to simulate the sampling of the parents for the experiment
n_sample = n_ind_exp                   # Number of individuals to be sampled to construct the c matrix  (This is just because c matrices become awfully large). Typically should be the same as n_ind_exp 

sequence_length = 1e+06                # Just have a single continuous chromosome that is simulated
r = (as.numeric(commandArgs(trailingOnly = TRUE)[2]))/sequence_length                            # Recombination rate (per site per generation) during the forward simulation of history
r_expt = (as.numeric(commandArgs(trailingOnly = TRUE)[3]))/sequence_length                       # Recombination rate to be used during during the experiment (Drosophila melanogaster ~ 1.4e-08)
r_msp = r/532                        # Recombination rate for the initial msprime simulation
AtleastOneRecomb = FALSE               # Whether there has to be at least one recombination event

#mu = 1.3e-06                          # Mutation rate of non_neutral mutations during the forward simulation of the history
mu_list = seq(commandArgs(trailingOnly = TRUE)[1], commandArgs(trailingOnly = TRUE)[1], length = nsims)  # If mu is to be varied in order to vary true Vw # (1.5-6.0 e-06 works splendidly)
mu_expt = 0                             # Mutation rate during the experiment

# mu_msp and mu_neutral are specified within the loop over sims

##############################
### DFE-related parameters ###
##############################

DFE = "g"                              # DFE can be "g" (gamma) or "n" (normal) 

# If DFE is "g"
shape = 0.3                                  # Shape of the gamma DFE ##### mean = shape*scale
scale_list = seq(0.033, 0.033, length = nsims)  # Vector of Scale of the gamma DFE
mut_ratio = 0                          # The ratio of beneficial:deleterious mutations in msprime

# If DFE is "n" need to specify the mean and the variance of the normal distribution
mean_alpha = 0
var_alpha_list = seq(0.00002, 0.0002, length = nsims) # Vector to store variance of normal DFE

############################################################################################
########## Analysis parameters to be fed as arguments of the function Vw_model  ############
############################################################################################

proj="BLoM" # projection type for allele frequencies: "LoM", "BLoM", "L" or "N"
LDdelta = FALSE
pa = 1
Vs = "LoNL" # "L" or "LoNL"
method="REML" # Can be "REML" or "MCMC"
randomise = TRUE # Should the reference allele be randomised for analysis?
bigalgebra = FALSE # Should bigalgebra be used for eigendecomposition?

# How is pdelta to be estimated? 
# Can be "optim" (using the function optim()), or "fixed" or "manual"(estimated by manually scanning a range of pdelta values)

pdelta_method = "no_analysis" # "optim" or "manual" or "fixed" or "no_analysis". If this is "no_analysis", the estimate of Vw is not calculated, but the rest of the code still runs.

if(pdelta_method=="fixed"){
  pdelta = 0 # Can be specified to any value
}

if(pdelta_method=="optim"){
  pdelta = NA # This triggers the use of optim() inside the function Vw_model()
}

if(pdelta_method=="manual"){
  
  nseq<-20 # The number of times pdelta is to be varied 
  pdelta_l = -1 # Lower limit of pdelta
  pdelta_u = 1 # Upper limit of pdelta
  pdelta<-seq(pdelta_l, pdelta_u, length=nseq)
  
}

# How should bdelta[1] (intercept) and bdelta[2] (slope of (p-q)) be estimated

bdelta_method = "estimate" # Can be "fixed" or "estimate"

if(bdelta_method=="estimate"){
  bdelta = c(NA, NA)
}else{
  bdelta = c(0, 0) # This only estimates the slope while keeping the intercept fixed at 0
}


####################################################################################################################################################

if(!DFE%in%c("n", "g")){stop("DFE must be one of 'g', 'n'")}
if(!pdelta_method%in%c("optim", "fixed", "manual", "no_analysis")){stop("pdelta_method must be one of 'optim', 'fixed', 'manual', 'no_analysis'")}
if(!bdelta_method%in%c("estimate", "fixed")){stop("bdelta_method must be one of 'estimate', 'fixed'")}
if(!randomise%in%c(TRUE, FALSE)){stop("randomise must be one of TRUE or FALSE")}
if(!simulate%in%c(TRUE, FALSE)){stop("simulate must be one of TRUE or FALSE")}
if(!analyse%in%c(TRUE, FALSE)){stop("analyse must be one of TRUE or FALSE")}

####################################################################################################################################################

##############################################################################
##### Create empty vectors for data that needs to be stored for each sim #####
##############################################################################

vA_left = rep(NA, nsims) # Average vA left in gen1
vA_true = rep(NA, nsims) # Additive genetic variance
va_true = rep(NA, nsims) # Additive genic variance
vA_est = rep(NA, nsims)  # Estimated vA from the model

pdelta_est = rep(NA, nsims) # pdelta is fixed to 0 or is estimated in each simulation with the help of maximum likelihood (implemented manually or using optim())
pdelta_var_est = rep(NA, nsims)
bdelta_intercept_est = rep(NA, nsims) # Estimate of bdelta[1] from the model
bdelta_slope_est = rep(NA, nsims) # Estimate of bdelta[2] from the model
bdelta_var_est = rep(NA, nsims)
sigma2delta_est = rep(NA, nsims)  # Estimate of var_alpha from asreml()

pdelta_emp = rep(NA, nsims)            # The actual pdelta
bdelta_intercept_emp = rep(NA, nsims)  # The actual bdelta_intercept
bdelta_slope_emp = rep(NA, nsims)      # The actual bdelta_slope
sigma2delta_emp = rep(NA, nsims)       # The actual variance in alpha  
s_pmq = rep(NA, nsims)                 # The actual bdelta_slope (from a simple linear model)

seg_sites = rep(NA, nsims) # Number of segregating sites in the parents' generation in each simulation
seg_sites_neu = rep(NA, nsims) # Number of neutral segregating sites
seg_sites_ben = rep(NA, nsims) # Number of segregating sites where the derived allele is beneficial
seg_sites_del = rep(NA, nsims) # Number of segregating sites where the derived allele is deleterious

mem = c() # Create an empty vector to track memory, to investigate crashes

for (sim in 1:nsims){
  
  if(simulate){
  
      # Specify the scale of the the gamma distribution or the variance of the normal distribution of selection coefficients
    
      scale = scale_list[sim] 
      var_alpha = var_alpha_list[sim]
      
      # Specify the mutation rate for the SLiM history simulation
      
      mu = mu_list[sim]
      mu_msp = ifelse(end_gen==2, mu/532, mu/5320)
      mu_neutral = ifelse(end_gen==2, mu_msp/3, mu/20)
      
      message(paste("Simulation", sim, "in progress..."))
    
  
  
      #####################################################
      ############# Run msprime (neutral burnin) ##########
      #####################################################
      
      message("Running msprime...")
      
      system(paste("python", msprime_burnin_path, Ne, n_ind, sequence_length, r_msp, mu_msp, shape, scale, slim_output_path, mut_ratio, DFE, mean_alpha, sqrt(var_alpha), Set_ID, sim))
      
      ###############################################################
      ################# Simulate the history in SLim ################
      ###############################################################
      
      message("Forward simulating the history using SLiM...")
      
      ### This has lot's of command line arguments. Creating separate strings for each argument
      
      arg1 = paste("-d mu=", mu, sep = "")
      arg2 = paste("-d shape=", shape, sep = "")
      arg3 = paste("-d scale=", scale, sep = "")
      arg4 = paste("-d sequence_length=", sequence_length, sep = "")
      arg5 = paste("-d r=", r, sep = "")
      arg6 = paste("-d ", shQuote(paste("msprime_output_path=","'", slim_output_path, "'", sep = "")), sep = "") # Path where the msprime burnin is stored (it's same as slim_output_path)
      arg7 = paste("-d ", shQuote(paste("slim_output_path=","'", slim_output_path, "'", sep = "")), sep = "") 
      arg8 = paste("-d end_gen=", end_gen, sep = "")
      arg9 = paste("-d output_freq=", output_freq, sep = "")
      arg10 = paste("-d mut_ratio=", mut_ratio, sep = "")
      arg11 = paste("-d n_ind_exp=", n_ind_exp, sep = "") # The population size is to be reduced to n_ind_exp in generation end_gen (to simulate sampling of the parents for the experiment)
      arg12 = paste("-d ", shQuote(paste("DFE=", "'", DFE, "'", sep = "")), sep = "")
      arg13 = paste("-d mean_alpha=", mean_alpha, sep = "")
      arg14 = paste("-d var_alpha=", var_alpha, sep = "")
      arg15 = paste("-d ", shQuote(paste("Set_ID=", "'", Set_ID, "'", sep = "")), sep = "")
      arg16 = paste("-d simulation=", sim, sep = "")
      
      system(paste("slim", arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, slim_history_path))
      
      ###################################################################
      ############### Add neutral mutations using msprime ###############
      ###################################################################
      
      message("Adding neutral mutations...")
      
      system(paste("python", msprime_add_neutral_path, slim_output_path, mu_neutral, Set_ID, sim))
      
      
      ###################################################
      ######### Simulate the experiment in SLiM #########
      ###################################################
      
      message("Forward simulating the experiment using SLiM...")
      
      ### Loop over the cage replicates
      
      for (cage in (1:n_cages)){
        
        message(paste("Cage", cage, "of simulation", sim, "in progress..."))
        
        
        ### This has lot's of command line arguments. Creating separate strings for each argument
        
        expt_arg1 = paste("-d mu=", mu_expt, sep = "")
        expt_arg2 = paste("-d shape=", shape, sep = "")
        expt_arg3 = paste("-d scale=", scale, sep = "")
        expt_arg4 = paste("-d sequence_length=", sequence_length, sep = "")
        expt_arg5 = paste("-d r=", r_expt, sep = "")
        expt_arg6 = paste("-d ", shQuote(paste("slim_output_path=","'", slim_output_path, "'", sep = "")), sep = "") 
        expt_arg7 = paste("-d mut_ratio=", mut_ratio, sep = "")
        expt_arg8 = paste("-d end_gen=", end_gen, sep = "")
        expt_arg9 = paste("-d ", shQuote(paste("DFE=", "'", DFE, "'", sep = "")), sep = "")
        expt_arg10 = paste("-d mean_alpha=", mean_alpha, sep = "")
        expt_arg11 = paste("-d var_alpha=", var_alpha, sep = "")
        expt_arg12 = paste("-d ngen_expt=", ngen_expt, sep = "")
        expt_arg13 = paste("-d ", shQuote(paste("Set_ID=", "'", Set_ID, "'", sep = "")), sep = "")
        expt_arg14 = paste("-d simulation=", sim, sep = "")
        expt_arg15 = paste("-d cage=", cage, sep = "")
        
        system(paste("slim", expt_arg1, expt_arg2, expt_arg3, expt_arg4, expt_arg5, expt_arg6, expt_arg7, expt_arg8, expt_arg9, expt_arg10, expt_arg11, expt_arg12, expt_arg13, expt_arg14, expt_arg15, slim_expt_path))
        
      }
    
  }
  
  if(analyse){
      
      ##################################################################################
      ##################################################################################
      ########                 Analysis of the parents' generation               #######
      ######## Calculate c matrix, L, true Vw, and the non-recombination matrix  #######
      ##################################################################################
      ##################################################################################
      
      
      message("Reading the state of the population in the parent's generation...")
      
      system(paste("python", 
                   extract_genomes_path,                                                      # Path of the python script (3_Extract_genomes.py)
                   paste(slim_output_path, "/", Set_ID, "_sim", sim, "_output_parents.txt", sep = ""),     # Path of the .txt file containing the SLiM output for the parent's generation (sys.argv[1])
                   paste(mutations_path, "/", Set_ID, "_sim", sim, "_mutations_parents.txt", sep = ""),                 # Path of the .txt output file containing the mutations in the parents' generation (sys.argv[2])
                   paste(c_matrix_path,"/", Set_ID, "_sim", sim, "_c_matrix_parents.csv", sep = ""),                   # Path of the .csv output file containing the c matrix for genomes in the parents' generation (sys.argv[3])
                   n_sample))                                                                 # Number of individuals to be sampled randomly to construct the c matrix (just for space issues). Typically should be set to same as n_ind_exp
      
      # Read genomes
      c_genome = read.csv(paste(c_matrix_path,  "/", Set_ID, "_sim", sim, "_c_matrix_parents.csv", sep =""), header=F) # as.integer done to avoid scientific notation
      
      # Delete the .csv file
      system(paste("rm", paste(c_matrix_path,  "/", Set_ID, "_sim", sim, "_c_matrix_parents.csv", sep =""), sep = " "))
      
      c_genome = as.matrix(c_genome)
      
      # Convert genome data into individual data (rows are individuals and columns are allele counts {0,1 or 2} at various sites). 
      # Note that genome 1 and genome 2 are from individual 1; 3 and 4 are from individual 2, and so on
      
      message("Calculating the C matrix for the parents' generation...")
      
      n_individuals = nrow(c_genome)/2
      n_sites = ncol(c_genome)
      
      c_ind = c_genome[seq(1, 2*n_individuals, 2),] + c_genome[seq(2, 2*n_individuals, 2),]
      
      # Remove c_genome to save memory
      rm("c_genome")
      gc(verbose = FALSE)
      
      # If one samples individuals from the parents' generation while building the c matrix (i.e. when sample_size is less than n_ind_exp), the sample may not contain some low frequency mutations, i.e. some loci are not segregating in the sample, but are in the parents' population
      
      # identify the loci that are missing in the sample
      
      missing_loci = which(colSums(c_ind)==0)
      retained_loci = which(colSums(c_ind)!=0)
      
      # Trim the c matrix to contain only the retained loci, i.e. the loci that are segregating in the sample
      
      c_ind = c_ind[,retained_loci]
      
      
      
      ## Read the list of mutations output generated by SLiM and subsequently cropped out as a separate file by Python (for the parents' generation)
      
      mutations_0 = read.table(paste(mutations_path, "/", Set_ID, "_sim", sim, "_mutations_parents.txt", sep = ""), header=T, sep = " ")
      
      # Sort mutations based on the Temp_ID, so that the order of loci matches the order in the C and L matrices
      
      mutations_0 = mutations_0[order(mutations_0$Temp_ID),]
      
      # Trim mutations to contain only the retained loci, i.e. the loci that are segregating in the sample
      
      mutations_0 = mutations_0[retained_loci,]
      
      # Calculate the number of loci that are retained
      
      n_individuals = nrow(c_ind)/2
      n_sites_ret = ncol(c_ind)
      seg_sites[sim] = n_sites_ret
      seg_sites_neu[sim] = sum(mutations_0$s == 0)
      seg_sites_ben[sim] = sum(mutations_0$s > 0)
      seg_sites_del[sim] = sum(mutations_0$s < 0)
      
      message(paste("There are", n_sites_ret, "Segregating sites in the parents' generation..."))
      
      
      ### Calculate true vA (additive genetic variance) and va (additive genic variance) 
      
      message("Computing the true Va in the parents' generation...")
      
      
      list_alpha = 2*(mutations_0$s)
      p_parents = colMeans(c_ind/2) # Allele frequencies in parents
      diversity = (p_parents)*(1 - p_parents)/2
      va_true[sim] = sum(diversity*list_alpha*list_alpha)     # Additive genic variance
      message(paste("The true Va in the parents' generation is", va_true[sim]))
      
      # Calculate the empirical relationship between alphas and 2p-1
      
      fit_s_pmq = lm(list_alpha ~ I(2*(mutations_0$Number)/n_ind_exp - 1))
      s_pmq[sim] = coef(fit_s_pmq)[2]
      rm("fit_s_pmq")
      gc(verbose = FALSE)
      
      if(pdelta_method!="no_analysis"){
        
        message("Calculating L in the parents' generation...")
        
        L = cov(c_ind/2)*(n_individuals-1)/(n_individuals)
        L = L[retained_loci, retained_loci] # Trim L to contain only the retained loci
        
        message("Calculating the true Vw in the parents' generation...")
        
        vA_true[sim] = t(list_alpha)%*%L%*%list_alpha         # Additive genetic variance
        
        gc(verbose = FALSE)
        
        message(paste("The true Vw in the parents' generation is", vA_true[sim]))
        
        message("Calculating the the matrix of non-recombinant fractions for the parents' generation...")
        
        # Calculate the non-recombinant fraction using Jarrod's function
        
        NRF = form_nR(mutations_0$Position, r_expt, sequence_length, AtleastOneRecomb)
      }
      
      
      
      
      
      ############################################################################
      ############################################################################
      ####### Calculate allele frequencies in the experiment for each cage #######
      ############################################################################
      ############################################################################  
      
      # Create empty vector to create the data frame containing the following variables as columns:
      # 1. Raw delta P
      # 2. Projected delta P
      # 3. Cage ID (replicate)
      # 4. Locus ID
      
      d_proj = c()
      d_raw = c()
      P_matrix = c()  
      
      for (cage in (1:n_cages)){
        
        ###############################
        ###### extract mutations ######
        ###############################
        
        
        # There are two command line arguments (1. Path of the SLiM output file, 2. Path where mutations are to be written) 
        
        
        message(paste("Extracting mutations and storing allele frequencies in cage ", cage, " of simulation ", sim, "...", sep = ""))
        
        for (gen in (end_gen + 1):(end_gen + 1 + ngen_expt)){
          #message(paste((gen-end_gen)*100/5, "% extracted..."))
          system(paste("python", 
                       extract_mut_path, 
                       paste(slim_output_path, "/", Set_ID, "_sim", sim, "_cage", cage, "_output_experiment_", as.integer(gen), ".txt", sep = ""), 
                       paste(mutations_path, "/", Set_ID, "_sim", sim, "_cage", cage, "_mutations_", as.integer(gen), ".txt", sep = ""))) # as.integer done to avoid scientific notation
        }
        
        
      
        
        ### Create an empty matrix to store allelic frequencies in each generation
        
        # If some of the loci get fixed/lost in subsequent generations, NAs should be inserted
        
        # Create an empty vector to store allele frequencies
        
        P = c()
        
        
        # store the frequencies in the parent's generation in P
        # Frequency = (Number of genomes)/(2*popsize)
        
        P = cbind(P, mutations_0$Number/(2*n_ind_exp))
        
        
        
        ### Loop through the generations of the experiment identifying mutations that were present in the parents' generation (using permanent IDs) and recording their frequencies
        
        for (gen in (end_gen+1):(end_gen+ngen_expt+1)){
          
          # Read the file storing mutation information
          mut = read.csv(paste(mutations_path, "/", Set_ID, "_sim", sim, "_cage", cage, "_mutations_", as.integer(gen), ".txt", sep = ""), sep = " ") # as.integer gets rid of scientific notation
          
          # Sort mutations based on the Temp_ID, so that the order of loci matches the order in the C and L matrices
          
          mut = mut[order(mut$Temp_ID),]
          
          # Create an empty vector to store frequencies of mutations in the current generation
          freq = c()
          
          # Loop through the permanent IDs of  mutations segregating in end_gen (parents' generation)
          # i.e. Loop through Permanent IDs in mutations_1
          # Check if each mutation is present in the current generation
          # If present, record the frequency in freq, otherwise add either 0 or 1 to freq using the round() function
          
          for(mutation in mutations_0$Permanent_ID){
            if(mutation %in% mut$Permanent_ID){freq = rbind(freq, (mut[which(mut$Permanent_ID==mutation),]$Number)/(2*n_ind_exp))
            }else{
              freq = rbind(freq, round(P[which(mutations_0$Permanent_ID==mutation), gen - end_gen]))
              #print(round(P[which(mutations_1$Permanent_ID==mutation), gen -1]))
            }
          }
          
          # Add the vector freq to P
          
          P = cbind(P, freq)
          #print(paste(round((gen-start_gen)*100/(end_gen-start_gen), 2), " % complete!"))
          
        }
       
        P_matrix = rbind(P_matrix, P)
        
      }
      
      
      ##### Calculate matrices of allele frequencies with rows as replicates ######
      
      pbar1 = matrix(NA, nrow = n_cages, ncol = n_sites)
      pbar2 = matrix(NA, nrow = n_cages, ncol = n_sites)
      for (i in 1:n_cages){
        pbar1[i,] = P_matrix[((i-1)*n_sites + 1):((i-1)*n_sites + n_sites),2] ## Matrix of frequencies at the start of the experiment (ie F1 generation)
      }
      
      for (i in 1:n_cages){
        pbar2[i,] = P_matrix[((i-1)*n_sites + 1):((i-1)*n_sites + n_sites),ngen_expt + 2] ## Matrix of frequencies at the end of the experiment
        
        
      }
      
      # Many loci get fixed between the parents' and the first generation
      # Loop through cages to calculate the average vA remaining in the first generation
      # This is not the actual vA in gen1, but really the vA in the parents' generation if the loci that were to be lost in gen1 were removed
      
      if(pdelta_method!="no_analysis"){
        
        vA_left_current = rep(NA, n_cages)
        
        for (cage in 1:n_cages){
          seg_sites_gen1 = which(pbar1[cage,]<1&pbar1[cage,]>0) # indices of sites segregating in gen1 of the experiment
          vA_left_current[cage] = t(list_alpha[seg_sites_gen1])%*%L[seg_sites_gen1, seg_sites_gen1]%*%list_alpha[seg_sites_gen1]
          
        }
        
        vA_left[sim] = mean(vA_left_current)
        
        message(paste("The average vA left in gen1 of the experiment is ", vA_left[sim]*100/vA_true[sim], "%"))
        
      }
      
      
      ################################################################
      ######## Randomise the reference allele in the c matrix ########
      ################################################################
      
      # Randomly change the reference allele
      # This can be done as follows:
      # Add 0s to the allele counts of those alleles that stay the same, and -2 to those alleles that are to be switched
      # Then take a mod
      
      
      if(randomise==TRUE&pdelta_method!="no_analysis"){
        message("Randomising reference alleles in c_ind...")
        # Generate a random vector of 0s (for no change) and -1s (for loci where the reference allele is to be switched)
        ran_vect = sample(c(0, -1), ncol(c_ind),  replace = T) 
        
        # Create a matrix with with as many rows as c_ind. 
        # Each row of this matrix should be made up of two times ran_vect (since we are working with allele counts, not frequencies). 
        # Because the same changes need to be applied to each individual
        
        ran_matrix = t(matrix(2*ran_vect, nrow = ncol(c_ind), ncol = nrow(c_ind)))
        
        # Calculate the allele counts of the new (randomised) reference alleles
        
        c_ind = abs(c_ind + ran_matrix)
        
      }
      
      ####################################################################
      ######## Randomise the reference allele in L and list_alpha ########
      ####################################################################
      
      if(randomise==TRUE&pdelta_method!="no_analysis"){
        
        message("Randomising reference alleles in L...")
        
        # Create a new vector of -1s (wherever ran_vect has -1) and 1s (wherever ran_vect has 0)
        ran_vect_L = ifelse(ran_vect==-1, -1, 1)
        
        # Calculate a matrix that decides which off-diagonal elements in L get their signs flipped
        
        ran_matrix_L = ran_vect_L%*%t(ran_vect_L)
        L = L*ran_matrix_L
        
        list_alpha = list_alpha*ran_vect_L
        
      }
      
      ###########################################################################
      ######## Randomise the reference allele in p_parents, pbar1 and pbar2 #####
      ###########################################################################
      
      # Randomly change the reference allele
      # This can be done as follows:
      # Add 0s to the frequencies of those alleles that stay the same, and -1 to those alleles that are to be switched
      # Then take a mod
      
      if(randomise==TRUE&pdelta_method!="no_analysis"){
        message("Randomising reference alleles in pbar1 and pbar2...")
        # Create a matrix with with as many rows as c_ind. Each row of this matrix should be made up of ran_vect (computed while randomising c_ind). 
        # Because the same changes need to be applied to each individual
        # Note that ran_vect needs to be restricted to retained loci
        
        ran_matrix_pbar = t(matrix(ran_vect, nrow = ncol(pbar1), ncol = nrow(pbar1)))
        
        # Calculate the frequencies of the new (randomised) reference alleles
        
        pbar1 = abs(pbar1 + ran_matrix_pbar)
        pbar2 = abs(pbar2 + ran_matrix_pbar)
        p_parents = abs(p_parents + ran_vect)
        
      }
      
      # 
      
      # Store the memory
      
      mem = cbind(mem, mem_used())
      
      # Garbage collection
      gc(verbose = FALSE)
      
      ##################################################
      ##################################################
      ######### Jarrod's code for analysis #############
      ##################################################
      ##################################################
      
      if(pdelta_method=="manual"){
      
      ### Fit the model serially varying pdelta, select the estimate that has the highest log likelihood
      
          LL<-vA_est_temp<-bdelta_intercept_temp<-bdelta_slope_temp<-bdelta_var_temp<-1:nseq # Creating empty vectors to store pdelta and estimated vA in each model
          
          
          for(i in 1:nseq){
            
            
            message("Saving a copy of the environment...")
            #save.image(file = paste(output_path, "/Output_temp", ".RData", sep ="")) # Save the output to investigate when things crash due to segfaults
            message("Performing analyses...")
            print(pdelta[i])
            
            m1<-Vw_model(C0 = c_ind/2,          # parental genotypes (rows individuals, columns loci, coded as 0, 1/2 or 1) 
                         nR = NRF,          # matrix of non-recombinant probabilities between loci
                         pbar1 = pbar1,       # vector of allele frequencies at time-point 1
                         ngen1=1,     # number of generations between parents and time-point 1
                         pbar2 = pbar2,       # vector of allele frequencies at time-point 2
                         ngen2 = ngen_expt + 1,       # number of generations between parents and time-point 2
                         nind = nrow(c_ind),        # population size in each replicate
                         proj=proj, # projection type for allele frequencies: "LoM", "BLoM", "L" or "N"
                         LDdelta = LDdelta,
                         pa = pa,
                         pdelta = pdelta[i],
                         bdelta = bdelta,
                         Vs = Vs,
                         method = method,
                         L = L,    # list with elements UL and DL
                         svdL = NULL,    # list with elements UL and DL
                         bigalgebra = bigalgebra, 
                         tol = sqrt(.Machine$double.eps))
            
            LL[i]<-m1$model$loglik
            vA_est_temp[i]<-m1$Vw_est
            bdelta_intercept_temp[i] = m1$bdelta[1]
            bdelta_slope_temp[i] = m1$bdelta[2]
            bdelta_var_temp[i] = paste(m1$bdelta_var[1,1], m1$bdelta_var[2,2], m1$bdelta_var[1,2], sep = "_") 
            sigma2delta_temp[i] = summary(m1$model)$varcomp[1,1]
            
            message(paste("Finding the best pdelta...", round((i/nseq)*100), "% complete"))
          }
          
          vA_est[sim] = vA_est_temp[which(LL == max(LL))] # Store the estimate from the model with the highest log likelihood
          pdelta_est[sim] = pdelta[which(LL == max(LL))]
          bdelta_intercept_est[sim] = bdelta_intercept_temp[which(LL == max(LL))]
          bdelta_slope_est[sim] = bdelta_slope_temp[which(LL == max(LL))]
          bdelta_var_est[sim] = bdelta_var_temp[which(LL == max(LL))]
          sigma2delta_est[sim] = sigma2delta_temp[which(LL == max(LL))]
          
          #plot(vA_est~vA_true, xlab = "True value of Vw", ylab = "Estimate of Vw")
          #abline(0,1)
          mem = cbind(mem, mem_used()) # Store the memory usage
      
      }
      
      
      if(pdelta_method=="fixed"|pdelta_method=="optim"){
        
        #message("Saving a copy of the environment...")
        #save.image(file = paste(output_path, "/Output_temp", ".RData", sep ="")) # Save the output to investigate when things crash due to segfaults
        message("Performing analyses...")
        m1<-Vw_model(C0 = c_ind/2,          # parental genotypes (rows individuals, columns loci, coded as 0, 1/2 or 1) 
                     nR = NRF,          # matrix of non-recombinant probabilities between loci
                     pbar1 = pbar1,       # vector of allele frequencies at time-point 1
                     ngen1=1,     # number of generations between parents and time-point 1
                     pbar2 = pbar2,       # vector of allele frequencies at time-point 2
                     ngen2 = ngen_expt + 1,       # number of generations between parents and time-point 2
                     nind = nrow(c_ind),        # population size in each replicate
                     proj=proj, # projection type for allele frequencies: "LoM", "BLoM", "L" or "N"
                     LDdelta = LDdelta,
                     pa = pa,
                     pdelta = pdelta,
                     bdelta = bdelta,
                     Vs = Vs,
                     method = method,
                     L = L,    # list with elements UL and DL
                     svdL = NULL,    # list with elements UL and DL
                     bigalgebra = bigalgebra, 
                     tol = sqrt(.Machine$double.eps))
        
        
        vA_est[sim] = m1$Vw_est # Store the estimate from the model with the highest log likelihood
        pdelta_est[sim] = m1$pdelta # The sample() functions ensures that only one value is selected in case there are multiple points with the highest LL
        pdelta_var_est[sim] = m1$pdelta_var
        bdelta_intercept_est[sim] = m1$bdelta[1]
        bdelta_slope_est[sim] = m1$bdelta[2]
        bdelta_var_est[sim] = paste(m1$bdelta_var[1,1], m1$bdelta_var[2,2], m1$bdelta_var[1,2], sep = "_")
        sigma2delta_est[sim] = summary(m1$model)$varcomp[1,1]
        #plot(vA_est~vA_true, xlab = "True value of Vw", ylab = "Estimate of Vw")
        #abline(0,1)
        
        mem = cbind(mem, mem_used()) # Store the memory usage
        
      }
      
      rm(list = c("c_ind", "NRF")) # Remove memory-heavy objects before the next simulation starts 
      # Garbage collection
      gc(verbose = FALSE)
  
  }
  
  ########################################################
  ##### Store empirical pdelta and bdelta for the sim ####
  ########################################################
  
  
   alpha_properties = alpha_distribution(alpha = list_alpha, p = p_parents)
   
   pdelta_emp[sim] = alpha_properties$pdelta
   bdelta_intercept_emp[sim] = alpha_properties$bdelta_int
   bdelta_slope_emp[sim] = alpha_properties$bdelta_slope
   sigma2delta_emp[sim] = alpha_properties$sigma2delta
  
  ########################################################
  ######### Save simulation data in a spreadsheet ########
  ########################################################
  
  if(record == TRUE){
  dat = read.csv(paste(output_path, "/", Set_ID, "_Data.csv", sep = ""), header=FALSE)
  dat = rbind(dat, c(Set_ID, as.character(Sys.time()), end_gen, ngen_expt, Ne, n_ind_exp, n_cages, sequence_length, r_msp, r, r_expt, mu_msp, mu, mu_neutral, shape, scale, mut_ratio, proj, LDdelta, pa, Vs, randomise, pdelta_method, bdelta_method, va_true[sim], vA_true[sim], vA_est[sim], vA_left[sim], pdelta_emp[sim], bdelta_intercept_emp[sim], bdelta_slope_emp[sim], sigma2delta_emp[sim], pdelta_est[sim], pdelta_var_est[sim], bdelta_intercept_est[sim], bdelta_slope_est[sim], bdelta_var_est[sim], sigma2delta_est[sim], seg_sites[sim], seg_sites_neu[sim], seg_sites_ben[sim], seg_sites_del[sim], s_pmq[sim]))
  write.table(dat, file = paste(output_path, "/", Set_ID, "_Data.csv", sep = ""),col.names = FALSE, row.names = FALSE, sep = ",")
  }
  
  
}

#pdf(paste(output_path, "/Output_",gsub(" ", "_", Sys.time()), ".pdf", sep = ""), onefile = F)

#plot(vA_est~vA_true, xlab = "True value of Vw", ylab = "Estimate of Vw")
#abline(0,1)

#dev.off()

#save.image(file = paste(output_path, "/output", gsub(" ", "_", Sys.time()), ".RData", sep =""))

