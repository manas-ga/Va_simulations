rm(list = ls())
# source("C:/Academics/Post-doc/Va_simulations/5_History_sim/00_History_sim_JARROD.R") ## Local windows

# source("/mnt/c/Academics/Post-doc/Va_simulations/5_History_sim/00_History_sim_JARROD.R") ## Local Wsl

# source("/data/home/msamant/Manas/Va_simulations/5_History_sim/00_History_sim_JARROD.R")  ## ON VERA


####################################
######### Packages #################
####################################

library(matlib)
library(MCMCglmm)
library(asreml)
library(Matrix)
library(rmutil)

########################################################################
########### paths of various scripts and functions #####################
########################################################################


### Base path (depending on the system) ###

if(Sys.info()["nodename"]=="vera.bio.ed.ac.uk"){
  
  base_path = "/data/home/msamant/Manas/Va_simulations/5_History_sim" ## ON VERA
  
}else{
  
  if(Sys.info()["sysname"]=="Linux"){
    
    base_path = "/mnt/c/Academics/Post-doc/Va_simulations/5_History_sim" ## Local Wsl
    
  }else{
    
    base_path = "C:/Academics/Post-doc/Va_simulations/5_History_sim" ## Local windows
    
  }
  
}


msprime_path = file.path(base_path, "0_neutral_burnin.py")                                                    ## msprime script generating the initial sequences
msprime_output_path = paste(base_path, "/b_Interim_files/Msprime_outputs/neutral_burnin.trees", sep = "")     ## Output file generated by msprime
slim_history_path = file.path(base_path, "1_History.slim")                                                    ## SLiM script running the history
slim_expt_path = file.path(base_path, "4_Experiment.slim")                                                    ## SLiM script running the experiment
extract_genomes_path = file.path(base_path, "3_Extract_genomes.py")                                           ## Python script extracting mutations and genomes from the SLiM output for gen1
extract_mut_path = file.path(base_path, "2_Extract_mutations.py")                                             ## Python script extracting mutations for the experimental generations
slim_output_path = paste(base_path, "/b_Interim_files/SLiM_outputs", sep = "")                                ## Path where SLiM output files are stored
mutations_path = paste(base_path, "/b_Interim_files/Mutations", sep = "")                                     ## Path for text file containing mutations generated by the python script  
c_matrix_path = paste(base_path, "/b_Interim_files/C_Matrices", sep = "")                                     ## .csv file storing c matrix generated by the python script
rdata_path = paste(base_path, "/b_Interim_files/Rdata", sep = "")
output_path = paste(base_path, "/c_Output", sep = "")



#####################################################
################# True Parameters ###################
#####################################################


Ne = 1e+06                # Population size


#####################################################
############ Simulation Parameters ##################
#####################################################

n_ind = 10000             # Number of individuals to be sampled in msprime and then run forward in SLiM
n_ind_exp = 1000          # The population size of the experiment. In 00_History.slim the population reduces to n_ind_exp in the last generation to simulate the sampling of the parents for the experiment
sequence_length = 1e+05   # Just have a single contuguous chromosome that is simulated
r = 1.4e-06               # Recombination rate (per site per generation)
r_expt = 1.4e-08          # Unscaled recombination rate to bee used during during the experiment
r_msp = 1.4e-08           # Recombination rate for msprime
mu = 1.3e-07               # Mutation rate during the forward simulation of the history
mu_msp = 1.3e-10           # A separate mutation rate for the msprime simulation
mu_expt = 0               # Mutation rate during the experiment
mut_ratio = 0.01           # The ratio of beneficial:deleterious mutations in msprime
shape = 0.2               # Shape of the gamma DFE ##### mean = shape*scale
scale = 0.1              # Scale of the gamma DFE

history_test = F # Plot population parameters during the history?

start_gen = 1
end_gen = 100          # How many generations should the SLiM simulation run for while simulating the history (burnin)
output_freq = 100        # The frequency with which SLiM outputs are to be generated for the analysis of history (optional)

n_sample = 1000           # Number of individuals to be sampled to construct the c matrix  (This is just because c matrices become awfully large) 
list_gen = seq(1,end_gen, output_freq) # List of generations for which measurements are to be made in the analysis of hostory
n_cages = 10              # The number of replicate cages in the experiment
projection = "LoM"            # The matrix along which allele frequency changes in the experiment are to be projected ("L" or "LoM")
p_alpha = 0 # Models the distribution of alphas; V_alpha = (sigma^2)*L^(P_alpha)
p_delta = 2 # Models the covariance structure of the expected allele frequency change under selection (var(E(delP)) = )
sinc<-1e-6            # increment added to diagonal of allelic effect covariance matrix to make pd
method = "REML"           # "REML" or "MCMCglmm" (while fitting the model to calculate vA)
ngen_expt = 3             # How many generations should allele frequency changes be calculated over in the experiment
nsims = 10              # Number of simulations (change scale in each simulation)

#### Jarrod's parameters

nind = 1000        # population size in each replicate
proj="BLoM" # projection type for allele frequencies: "LoM", "BLoM", "L" or "N"
LDdelta = T
pa = 1
pdelta=0
Vs = "LoNL"
method="REML"
L=NULL    # list with elements UL and DL
svdL=NULL    # list with elements UL and DL
tol=sqrt(.Machine$double.eps)



# Create empty vectors to store true vA and estimates of vA from the model

vA_true = rep(NA, nsims) # Additive genetic variance
va_true = rep(NA, nsims) # Additive genic variance
vA_est = rep(NA, nsims)
scale_list = rep(NA, nsims) # Vector to store scales



for (sim in 0:nsims){
  
    # Specify the scale of the the gamma distribution of selection coefficients
  
    scale = 0.075 + (sim/nsims)*0.175
    scale_list[sim] = scale
    
    message(paste("Simulation", sim, "in progress..."))
  


    #####################################################
    ################# Run msprime #######################
    #####################################################
    
    message("Running msprime...")
    
    system(paste("python", msprime_path, Ne, n_ind, sequence_length, r_msp, mu_msp, shape, scale, msprime_output_path, mut_ratio))
    
    #####################################################
    ################# Run SLiM ##########################
    #####################################################
    
    message("Forward simulating the history using SLiM...")
    
    ### This has lot's of command line arguments. Creating separate strings for each argument
    
    arg1 = paste("-d mu=", mu, sep = "")
    arg2 = paste("-d shape=", shape, sep = "")
    arg3 = paste("-d scale=", scale, sep = "")
    arg4 = paste("-d sequence_length=", sequence_length, sep = "")
    arg5 = paste("-d r=", r, sep = "")
    
    #arg6 = paste("-d msprime_output_path=","'", msprime_output_path, "'", sep = "") # Only works on Windows
    #arg7 = paste("-d slim_output_path=", "'", slim_output_path, "'", sep = "") # Only works on Windows
    
    arg6 = paste("-d ", shQuote(paste("msprime_output_path=","'", msprime_output_path, "'", sep = "")), sep = "")
    arg7 = paste("-d ", shQuote(paste("slim_output_path=","'", slim_output_path, "'", sep = "")), sep = "") 
    
    arg8 = paste("-d end_gen=", end_gen, sep = "")
    arg9 = paste("-d output_freq=", output_freq, sep = "")
    arg10 = paste("-d mut_ratio=", mut_ratio, sep = "")
    arg11 = paste("-d n_ind_exp=", n_ind_exp, sep = "") # The population size is to be reduced to n_ind_exp in generation end_gen (to simulate sampling of the parents for the experiment)
    
    system(paste("slim", arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, slim_history_path))
    
    
    
    ########################################################################################################################
    ########################################################################################################################
    #### Calculate true vA, L, and the non-recombination matrix in the last history generation (the parents' generation) ###
    ########################################################################################################################
    ########################################################################################################################
    
    message("Reading the state of the population in the parent's generation")
    
    system(paste("python", extract_genomes_path, paste(slim_output_path, "/Output_", as.integer(end_gen), ".txt", sep = ""), mutations_path, c_matrix_path, n_sample, as.integer(end_gen)))
    
    # Read genomes
    c_genome = read.csv(paste(c_matrix_path, "/c_matrix_", as.integer(end_gen), ".csv", sep =""), header=F) # as.integer done to avoid scientific notation
    
    c_genome = as.matrix(c_genome)
    
    #Convert genome data into individual data (rows are individuals and columns are allele counts {0,1 or 2} at various sites). 
    # Note that genome 1 and genome 2 are from individual 1, and so on
    
    message("Calculating the C matrix for the parents' generation...")
    
    n_individuals = nrow(c_genome)/2
    n_sites = ncol(c_genome)
    
    c_ind = c_genome[seq(1, 2*n_individuals, 2),] + c_genome[seq(2, 2*n_individuals, 2),]
    
    
    
    #### Calculate the matrix of second mixed moments of c, ie. the L matrix
    
    message("Calculating the L matrix for the parents' generation...")
    
    L = cov(c_ind/2)
    
    # Check for 0s on the diagonal of L
    #which(diag(L)==0)
    
    ####### Notice that L has some 0s on the diagonal
    # This is happening because when I sample individuals in SLiM from a population of 10000, the sample does not contain some low frequency mutations, ie. some loci are not segregating in the sample, but are in the original population
    
    # identify the loci that are missing in the sample
    
    missing_loci = which(diag(L)==0)
    retained_loci = which(diag(L)!=0)
    
    # Trim L to contain only the retained loci
    
    L_ret = L[retained_loci,retained_loci]
    
    # Trim the c matrix to contain only the retained loci, i.e. the loci that are segregating in the sample
    
    c_ind_ret = c_ind[,retained_loci]
    
    # Correlation matrix
    
    #R = cov2cor(L_ret)
    
    
    ## Read the list of mutations output generated by SLiM and subsequently cropped out as a separate file by Python
    # From the first generation
    
    mutations_0 = read.table(paste(mutations_path, "/Mutations_", as.integer(end_gen), ".txt", sep = ""), header=T, sep = " ")
    
    # Sort mutations based on the Temp_ID, so that the order of loci matches the order in the C and L matrices
    
    mutations_0 = mutations_0[order(mutations_0$Temp_ID),]
    
    # Trim mutations to contain only the retained loci, i.e. the loci that are segregating in the sample
    
    mutations_ret = mutations_0[retained_loci,]
    
    # Calculate the number of loci that are retained
    
    n_sites_ret = ncol(c_ind_ret)
    
    ################################
    ### Calculate true vA and va ###
    ################################
    
    message("Computing the actual Va for the starting population...")
    
    
    list_alpha = mutations_ret$s
    
    vA_true[sim] = t(list_alpha)%*%L_ret%*%list_alpha  # Additive genetic variance
    va_true[sim] = sum(diag(L_ret)*list_alpha*list_alpha) # Additive genic variance
    
    
    
      
    message("Calculating the the matrix of non-recombinant fractions for the starting population...")
    
    dist = matrix(0, nrow(L_ret), nrow(L_ret)) # Matrix of paired distances
    
    # Loop through columns 
    
    for (site in 1:nrow(L_ret)){
      dist[, site] = abs(mutations_ret$Position - mutations_ret$Position[site])
      #rf = 0.5*(1 - exp(-2*dist*r_expt))
      #NRF[, site] =  1 - rf
    }
    
    NRF = 1 - 0.5*(1 - exp(-2*dist*r_expt))
      
      
    
    #######################################################################################
    #######################################################################################
    ################################## Experiment #########################################
    #######################################################################################
    #######################################################################################
    
    message("Forward simulating the experiment using SLiM...")
    
    # Create empty vector to create the data frame containing the following variables as columns:
    # 1. Raw delta P
    # 2. Projected delta P
    # 3. Cage ID (replicate)
    # 4. Locus ID
    
    d_proj = c()
    d_raw = c()
    P_matrix = c()
    
    ### Loop over the cage replicates
    
    for (cage in (1:n_cages)){
      
      message(paste("Cage", cage, "of simulation", sim, "in progress..."))
      
      #######################
      ###### run SLiM #######
      #######################   
        
      # SLiM by default generates random seeds in a very odd way (based on the clock and process ID)
      # Generate a random seed for SLiM
      
      #slim_seed = sample(1:100000, 1)
      
      
      
      ### This has lot's of command line arguments. Creating separate strings for each argument
      
      expt_arg1 = paste("-d mu=", mu_expt, sep = "")
      expt_arg2 = paste("-d shape=", shape, sep = "")
      expt_arg3 = paste("-d scale=", scale, sep = "")
      expt_arg4 = paste("-d sequence_length=", sequence_length, sep = "")
      expt_arg5 = paste("-d r=", r_expt, sep = "")
      
      #arg6 = paste("-d msprime_output_path=","'", msprime_output_path, "'", sep = "") # Only works on Windows
      
      expt_arg6 = paste("-d ", shQuote(paste("slim_output_path=","'", slim_output_path, "'", sep = "")), sep = "") 
      expt_arg7 = paste("-d mut_ratio=", mut_ratio, sep = "")
      expt_arg8 = paste("-d end_gen=", end_gen, sep = "")
      
      
      system(paste("slim", expt_arg1, expt_arg2, expt_arg3, expt_arg4, expt_arg5, expt_arg6, expt_arg7, expt_arg8, slim_expt_path))
      
      
      ###############################
      ###### extract mutations ######
      ###############################
      
      # There are three command line arguments (1. Path of the SLiM output file, 2. Path where mutations are to be written, 3. gen) 
      
      
      message("Extracting mutations...")
      
      for (gen in (end_gen + 1):(end_gen + 4)){
        message(paste((gen-end_gen)*100/5, "% extracted..."))
        system(paste("python", extract_mut_path, paste(slim_output_path, "/Output_experiment_", as.integer(gen), ".txt", sep = ""), mutations_path, as.integer(gen))) # as.integer done to avoid scientific notation
      }
      
      
    
      
      ### Create an empty matrix to store allelic frequencies in each generation
      
      # If some of the loci get fixed/lost in subsequent generations, NAs should be inserted
      
      message("Storing allele frequencies...")
      
      # Create an empty vector to store allele frequencies
      
      P = c()
      
      
      # store the frequencies in the parent's generation in P
      # Frequency = (Number of genomes)/(2*popsize)
      
      P = cbind(P, mutations_ret$Number/(2*n_ind_exp))
      
      
      
      ### Loop through the generations of the experiment identifying mutations that were present in the parents' generation (using permanent IDs) and recording their frequencies
      
      for (gen in (end_gen+1):(end_gen+ngen_expt+1)){
        # Read the file storing mutation information
        mut = read.csv(paste(mutations_path ,"/Mutations_", as.integer(gen), ".txt", sep = ""), sep = " ") # as.integer gets rid of scientific notation
        
        # Sort mutations based on the Temp_ID, so that the order of loci matches the order in the C and L matrices
        
        mut = mut[order(mut$Temp_ID),]
        
        # Create an empty vector to store frequencies of mutations in the current generation
        freq = c()
        
        # Loop through the permanent IDs of  mutations segregating in end_gen (parents' generation)
        # i.e. Loop through Permanent IDs in mutations_1
        # Check if each mutation is present in the current generation
        # If present, record the frequency in freq, otherwise add either 0 or 1 to freq using the round() function
        
        for(mutation in mutations_ret$Permanent_ID){
          if(mutation %in% mut$Permanent_ID){freq = rbind(freq, (mut[which(mut$Permanent_ID==mutation),]$Number)/(2*n_ind_exp))
          }else{
            freq = rbind(freq, round(P[which(mutations_ret$Permanent_ID==mutation), gen - end_gen]))
            #print(round(P[which(mutations_1$Permanent_ID==mutation), gen -1]))
          }
        }
        
        # Add the vector freq to P
        
        P = cbind(P, freq)
        #print(paste(round((gen-start_gen)*100/(end_gen-start_gen), 2), " % complete!"))
        
      }
     
      P_matrix = rbind(P_matrix, P)
      
    }
    
    
    ##### Calculate matrices of allele frequencies with rows as replicates ######
    
    pbar1 = matrix(NA, nrow = n_cages, ncol = n_sites)
    pbar2 = matrix(NA, nrow = n_cages, ncol = n_sites)
    for (i in 1:n_cages){
      pbar1[i,] = P_matrix[((i-1)*n_sites + 1):((i-1)*n_sites + n_sites),2]
    }
    
    for (i in 1:n_cages){
      pbar2[i,] = P_matrix[((i-1)*n_sites + 1):((i-1)*n_sites + n_sites),5]
      
      
    }
    
    
    ##################################################
    ######### Jarrod's code for analysis #############
    ##################################################
    
    message("Fitting the model...")
    
    C0 = c_ind_ret/2          # parental genotypes (rows individuals, columns loci, coded as 0, 1/2 or 1) 
    nR = NRF          # matrix of non-recombinant probabilities between loci
    pbar1 = pbar1       # vector of allele frequencies at time-point 1
    ngen1=1     # number of generations between parents and time-point 1
    pbar2 = pbar2       # vector of allele frequencies at time-point 2
    ngen2 = 4       # number of generations between parents and time-point 2
    #nind = 1000        # population size in each replicate
    #proj="BLoM" # projection type for allele frequencies: "LoM", "BLoM", "L" or "N"
    #LDdelta = T
    #pa = 1
    #pdelta=0
    #Vs = "LoNL"
    #method="REML"
    #L=NULL    # list with elements UL and DL
    #svdL=NULL    # list with elements UL and DL
    #tol=sqrt(.Machine$double.eps)
    nrep = 10
    
    
    
    if(is.null(L)){
      L<-cov(C0)*(nind-1)/(nind)
    }
    
    if(!proj%in%c("LoM", "BLoM", "L", "N")){stop("proj must be one of 'LoM', 'L', 'N'")}
    if(!Vs%in%c("LoNL", "L")){stop("Vs must be either 'LoNL' or 'L'")}
    if(!method%in%c("REML", "MCMC")){stop("method must be either 'REML' or 'MCMC'")}
    
    #################################
    # calculate projection matrices #
    #################################
    nsnps<-ncol(C0)
    
    if(proj=="L" | proj=="BLoM" | LDdelta){
      
      if(is.null(svdL)){
        svdC<-svd(t(scale(sqrt(1/nind)*C0, scale=FALSE)))
        retain<-sum(svdC$d>tol)
        U<-svdC$u[,1:retain]
        D<-diag(svdC$d[1:retain])
      }else{
        U<-svdL$UL
        D<-diag(svdL$DL)
        retain<-ncol(U)
      }
      if(LDdelta){
        DL<-D
        UL<-U
      }
    }
    
    if(proj=="LoM" | proj=="BLoM"){ 
      
      M<-Reduce('+', sapply(1+ngen1:(ngen2-ngen1), function(x){((1-1/(2*nind))^(x-1))*(1/nind)*nR^x}, simplify=FALSE))
      
      if(proj=="LoM"){
        sdLoM<-RSpectra::eigs(L*M, min(nind, nsnps))
        retain<-sum(sqrt(sdLoM$values)>tol)
        U<-sdLoM$vectors[,1:retain]
        D<-diag(sqrt(sdLoM$values[1:retain]))
      }
      
      if(proj=="BLoM"){ 
        sdLoM<-RSpectra::eigs(t(U)%*%(L*M)%*%U, ncol(U))
        retain<-sum(sqrt(sdLoM$values)>tol)
        U<-U%*%sdLoM$vectors[,1:retain]
        D<-diag(sqrt(sdLoM$values[1:retain]))
      }   
    } 
    
    
    if(proj=="N"){
      
      projp<-diag(nrow(pbar1)) #### changed from length(pbar1) to nrow(pbar1)
      
    }else{
      
      projp<-U%*%diag(diag(D)^(-pa))
      
    }
    
    if(LDdelta){
      if(pdelta==0){
        covp<-diag(nsnps)
      }else{
        covp<-UL%*%diag(diag(DL)^(2*pdelta))%*%t(UL)
      }  
    }else{
      covp<-diag(diag(L)^pdelta)
    }
    
    if(Vs=="LoNL"){
      N<-Reduce('+', sapply(1+ngen1:(ngen2-ngen1), function(x){((1-1/(2*nind))^(x-1))*nR^(x-1)}, simplify=FALSE))
      
      covp<-(L*N)%*%covp%*%(L*N)
    }
    if(Vs=="L"){
      covp<-(L*(ngen2 - ngen1))%*%covp%*%(L*(ngen2 - ngen1))
    }  
    
    
    SC<-t(projp)%*%covp%*%projp
    
    attr(SC, "INVERSE")<-FALSE
    dimnames(SC) <- list(1:nrow(SC),1:ncol(SC))  # used for full-form matrices, ## changing "retain" to "nrow(SC)" as retain does not exist when proj = "N" 
    
    pbar1_proj<-pbar1%*%projp 
    pbar2_proj<-pbar2%*%projp 
    
    dat.gaussian<-data.frame(delta=c(pbar2_proj-pbar1_proj), locus=gl(ncol(pbar1_proj),nrep,ncol(pbar1_proj)*nrep), rep=gl(nrep,1,ncol(pbar1_proj)*nrep))
    
    ##############
    # Fit models #
    ##############
    
    prior<-list(R=list(V=1, nu=0), G=list(G1=list(V=1, nu=1, alpha.mu=0, alpha.V=1000)))
    
    if(method=="REML"){
      m1<-asreml(delta~1, random = ~vm(locus, SC), data=dat.gaussian)
    }
    if(method=="MCMC"){
      
      invSC<-solve(t(projp)%*%covp%*%projp)
      invSC <- as(invSC, "sparseMatrix") 
      attr(invSC, "rowNames") <- 1:retain
      attr(invSC, "colNames") <- 1:retain
      
      m1<-MCMCglmm(delta~1, random=~locus, data=dat.gaussian, ginverse=list(locus=invSC), family="gaussian", pr=TRUE, prior=prior)
    }
    
    if(LDdelta){
      TrV<-sum(diag(DL)^(2*(pdelta+1)))
    }else{
      TrV<-sum(diag(L%*%diag(diag(L)^pdelta)))
    }
    
    if(method=="REML"){
      Vw_est<-summary(m1)$varcomp[1,1]*TrV
    }
    if(method=="MCMC"){
      Vw_est<-posterior.mode(m1$VCV[,1])*TrV
    }
    
    #return(list(Vw_est=Vw_est, data=dat.gaussian, model=m1, SC=SC))
    
    vA_est[sim] = Vw_est

}

save.image(file = paste(output_path, "/Output.RData", sep =""))
