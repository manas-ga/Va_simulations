rm(list = ls())
# source("C:/Academics/Post-doc/Va_simulations/5_History_sim/00_History_sim.R") ## Local windows

# source("/mnt/c/Academics/Post-doc/Va_simulations/5_History_sim/00_History_sim.R") ## Local Wsl

# source("/data/home/msamant/Manas/Va_simulations/5_History_sim/00_History_sim.R")  ## ON VERA


####################################
######### Packages #################
####################################

library(matlib)
library(MCMCglmm)
library(asreml)
library(Matrix)
library(rmutil)

########################################################################
########### paths of various scripts and functions #####################
########################################################################

# base_path = "C:/Academics/Post-doc/Va_simulations/5_History_sim" ## Local windows

# base_path = "/mnt/c/Academics/Post-doc/Va_simulations/5_History_sim" ## Local Wsl

base_path = "/data/home/msamant/Manas/Va_simulations/5_History_sim" ## ON VERA

msprime_path = file.path(base_path, "0_neutral_burnin.py")                                                    ## msprime script generating the initial sequences
msprime_output_path = paste(base_path, "/b_Interim_files/Msprime_outputs/neutral_burnin.trees", sep = "")     ## Output file generated by msprime
slim_history_path = file.path(base_path, "1_History.slim")                                                    ## SLiM script running the history
slim_expt_path = file.path(base_path, "4_Experiment.slim")                                                    ## SLiM script running the experiment
extract_genomes_path = file.path(base_path, "3_Extract_genomes.py")                                           ## Python script extracting mutations and genomes from the SLiM output for gen1
extract_mut_path = file.path(base_path, "2_Extract_mutations.py")                                             ## Python script extracting mutations for the experimental generations
slim_output_path = paste(base_path, "/b_Interim_files/SLiM_outputs", sep = "")                                ## Path where SLiM output files are stored
mutations_path = paste(base_path, "/b_Interim_files/Mutations", sep = "")                                     ## Path for text file containing mutations generated by the python script  
c_matrix_path = paste(base_path, "/b_Interim_files/C_Matrices", sep = "")                                     ## .csv file storing c matrix generated by the python script
rdata_path = paste(base_path, "/b_Interim_files/Rdata", sep = "")
output_path = paste(base_path, "/c_Output", sep = "")



#####################################################
################# True Parameters ###################
#####################################################


Ne = 1e+06                # Population size


#####################################################
############ Simulation Parameters ##################
#####################################################

n_ind = 10000             # Number of individuals to be sampled in msprime and then run forward in SLiM
n_ind_exp = 1000          # The population size of the experiment. In 00_History.slim the population reduces to n_ind_exp in the last generation to simulate the sampling of the parents for the experiment
sequence_length = 1e+05   # Just have a single contuguous chromosome that is simulated
r = 1.4e-06               # Recombination rate (per site per generation)
r_expt = 1.4e-08          # Unscaled recombination rate to bee used during during the experiment
r_msp = 1.4e-08           # Recombination rate for msprime
mu = 1.3e-07               # Mutation rate during the forward simulation of the history
mu_msp = 1.3e-10           # A separate mutation rate for the msprime simulation
mu_expt = 0               # Mutation rate during the experiment
mut_ratio = 0.1           # The ratio of beneficial:deleterious mutations in msprime
shape = 0.2               # Shape of the gamma DFE ##### mean = shape*scale
scale = 0.25              # Scale of the gamma DFE

history_test = F # Plot population parameters during the history?

start_gen = 1
end_gen = 100000          # How many generations should the SLiM simulation run for while simulating the history (burnin)
output_freq = 2000        # The frequency with which SLiM outputs are to be generated for the analysis of history (optional)

n_sample = 1000           # Number of individuals to be sampled to construct the c matrix  (This is just because c matrices become awfully large) 
list_gen = seq(1,end_gen, output_freq) # List of generations for which measurements are to be made in the analysis of hostory
n_cages = 10              # The number of replicate cages in the experiment
projection = "LoM"            # The matrix along which allele frequency changes in the experiment are to be projected ("L" or "LoM")
p_alpha = 0 # Models the distribution of alphas; V_alpha = (sigma^2)*L^(P_alpha)
sinc<-1e-6            # increment added to diagonal of allelic effect covariance matrix to make pd
method = "REML"           # "REML" or "MCMCglmm" (while fitting the model to calculate vA)
ngen_expt = 2             # How many generations should allele frequency changes be calculated over in the experiment

#####################################################
################# Run msprime #######################
#####################################################

message("Running msprime...")

system(paste("python", msprime_path, Ne, n_ind, sequence_length, r_msp, mu_msp, shape, scale, msprime_output_path, mut_ratio))

#####################################################
################# Run SLiM ##########################
#####################################################

message("Forward simulating the history using SLiM...")

### This has lot's of command line arguments. Creating separate strings for each argument

arg1 = paste("-d mu=", mu, sep = "")
arg2 = paste("-d shape=", shape, sep = "")
arg3 = paste("-d scale=", scale, sep = "")
arg4 = paste("-d sequence_length=", sequence_length, sep = "")
arg5 = paste("-d r=", r, sep = "")

#arg6 = paste("-d msprime_output_path=","'", msprime_output_path, "'", sep = "") # Only works on Windows
#arg7 = paste("-d slim_output_path=", "'", slim_output_path, "'", sep = "") # Only works on Windows

arg6 = paste("-d ", shQuote(paste("msprime_output_path=","'", msprime_output_path, "'", sep = "")), sep = "")
arg7 = paste("-d ", shQuote(paste("slim_output_path=","'", slim_output_path, "'", sep = "")), sep = "") 

arg8 = paste("-d end_gen=", end_gen, sep = "")
arg9 = paste("-d output_freq=", output_freq, sep = "")
arg10 = paste("-d mut_ratio=", mut_ratio, sep = "")
arg11 = paste("-d n_ind_exp=", n_ind_exp, sep = "") # The population size is to be reduced to n_ind_exp in generation end_gen (to simulate sampling of the parents for the experiment)

system(paste("slim", arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, slim_history_path))






#########################################################################
################# Analysis of the history phase #########################
#########################################################################

# This analysis tracks the evolution of Va, VA, diversity and seg_sites through the course of the history
# No need to run this for the analysis of the experiment itself

if (history_test == T){

message("Computing VA, Va, diversity and segregating sites...")
  
#################################################################
########## Extract mutations and/or c matrices ##################
#################################################################

#### Extract just the mutations

# There are three command line arguments (1. Path of the SLiM output file, 2. Path where mutations are to be written, 3. gen)

# message("Extracting mutations...")

#for (gen in list_gen){

#  system(paste("python", extract_mut_path, paste(slim_output_path, "/Output_", gen, ".txt", sep = ""), mutations_path, gen))
#}


#### Extract c_matrices as well as mutations

# There are five command line arguments (1. Path of the SLiM output file, 2. Path where mutations aret o be written 
# 3. Path where the .csv files are to be written, 4. Number of individuals to be sampled to construct the c-Matrix 5. gen)

message("Extracting mutations and genomes...")

for (gen in list_gen){
  message(paste(gen*100/end_gen, "% extracted..."))
  system(paste("python", extract_genomes_path, paste(slim_output_path, "/Output_", gen, ".txt", sep = ""), mutations_path, c_matrix_path, n_sample, gen))
}


### Loop through generations and compute:
# 1. VA
# 2. Va (Additive genic variance)
# 3. Number of segregating sites
# 4. average genetic dversity

vA = rep(NA, length(list_gen))
va = rep(NA, length(list_gen))
seg_sites = rep(NA, length(list_gen))
diversity = rep(NA, length(list_gen))


for (gen in list_gen){
  
  # Read genomes
  c_genome = read.csv(paste(c_matrix_path, "/c_matrix_", as.integer(gen), ".csv", sep =""), header=F)
  
  c_genome = as.matrix(c_genome)
  
  #Convert genome data into individual data (rows are individuals and columns are allele counts {0,1 or 2} at various sites). 
  # Note that genome 1 and genome 2 are from individual 1, and so on
  
  n_individuals = nrow(c_genome)/2
  n_sites = ncol(c_genome)
  
  c_ind = c_genome[seq(1, 2*n_individuals, 2),] + c_genome[seq(2, 2*n_individuals, 2),]
  
  
  
  #### Calculate the matrix of second mixed moments of c, ie. the L matrix
  
  
  L = cov(c_ind/2)
  
  # Check for 0s on the diagonal of L
  #which(diag(L)==0)
  
  ####### Notice that L has some 0s on the diagonal
  # This is happening because when I sample individuals in SLiM from a population of 10000, the sample does not contain some low frequency mutations, ie. some loci are not segregating in the sample, but are in the original population
  
  # identify the loci that are missing in the sample
  
  missing_loci = which(diag(L)==0)
  retained_loci = which(diag(L)!=0)
  
  # Trim L to contain only the retained loci
  
  L_ret = L[retained_loci,retained_loci]
  
  # Trim the c matrix to contain only the retained loci, i.e. the loci that are segregating in the sample
  
  c_ind_ret = c_ind[,retained_loci]
  
  # Correlation matrix
  
  #R = cov2cor(L_ret)
  
  
  ## Read the list of mutations output generated by SLiM and subsequently cropped out as a separate file by Python
  # From the first generation
  
  mutations = read.table(paste(mutations_path, "/Mutations_", as.integer(gen), ".txt", sep = ""), header=T, sep = " ")
  
  # Sort mutations based on the Temp_ID, so that the order of loci matches the order in the C and L matrices
  
  mutations = mutations[order(mutations$Temp_ID),]
  
  ########################################################################
  ####### Note the number of segregating sites and summed diversity ######
  ########################################################################
  
  seg_sites[(gen-1)/output_freq + 1] = nrow(mutations)
  diversity[(gen-1)/output_freq + 1] = mean(2*((mutations$Number)/(2*n_ind))*(1-(mutations$Number)/(2*n_ind)))
  
  #######################################################################
  
  # Trim mutations to contain only the retained loci, i.e. the loci that are segregating in the sample
  
  mutations_ret = mutations[retained_loci,]
  
  # Calculate the number of loci that are retained
  
  n_sites_ret = ncol(c_ind_ret)
  
  
  
  
  
  
  ####################################
  ####### Note VA and Va #############
  ####################################
  
  list_alpha = mutations_ret$s
  
  vA[(gen-1)/output_freq + 1] = t(list_alpha)%*%L_ret%*%list_alpha  # Additive genetic variance
  va[(gen-1)/output_freq + 1] = sum(diag(L_ret)*list_alpha*list_alpha) # Additive genic variance
  
  #plot(list_gen, seg_sites)
  
  message(paste(gen*100/end_gen, "% complete..."))
}


}

###################################################################################################################
###################################################################################################################
#### Calculate true vA, L, and the projection matrices in the last history generation (the parents' generation) ###
###################################################################################################################
###################################################################################################################

message("Reading the state of the population in the parent's generation")

system(paste("python", extract_genomes_path, paste(slim_output_path, "/Output_", as.integer(end_gen), ".txt", sep = ""), mutations_path, c_matrix_path, n_sample, as.integer(end_gen)))

# Read genomes
c_genome = read.csv(paste(c_matrix_path, "/c_matrix_", as.integer(end_gen), ".csv", sep =""), header=F) # as.integer done to avoid scientific notation

c_genome = as.matrix(c_genome)

#Convert genome data into individual data (rows are individuals and columns are allele counts {0,1 or 2} at various sites). 
# Note that genome 1 and genome 2 are from individual 1, and so on

message("Calculating the C matrix for the parents' generation...")

n_individuals = nrow(c_genome)/2
n_sites = ncol(c_genome)

c_ind = c_genome[seq(1, 2*n_individuals, 2),] + c_genome[seq(2, 2*n_individuals, 2),]



#### Calculate the matrix of second mixed moments of c, ie. the L matrix

message("Calculating the L matrix for the parents' generation...")

L = cov(c_ind/2)

# Check for 0s on the diagonal of L
#which(diag(L)==0)

####### Notice that L has some 0s on the diagonal
# This is happening because when I sample individuals in SLiM from a population of 10000, the sample does not contain some low frequency mutations, ie. some loci are not segregating in the sample, but are in the original population

# identify the loci that are missing in the sample

missing_loci = which(diag(L)==0)
retained_loci = which(diag(L)!=0)

# Trim L to contain only the retained loci

L_ret = L[retained_loci,retained_loci]

# Trim the c matrix to contain only the retained loci, i.e. the loci that are segregating in the sample

c_ind_ret = c_ind[,retained_loci]

# Correlation matrix

#R = cov2cor(L_ret)


## Read the list of mutations output generated by SLiM and subsequently cropped out as a separate file by Python
# From the first generation

mutations_0 = read.table(paste(mutations_path, "/Mutations_", as.integer(end_gen), ".txt", sep = ""), header=T, sep = " ")

# Sort mutations based on the Temp_ID, so that the order of loci matches the order in the C and L matrices

mutations_0 = mutations_0[order(mutations_0$Temp_ID),]

# Trim mutations to contain only the retained loci, i.e. the loci that are segregating in the sample

mutations_ret = mutations_0[retained_loci,]

# Calculate the number of loci that are retained

n_sites_ret = ncol(c_ind_ret)

######## Eigen decomposition of the projection matrix
# Can project on L or LoM depending on the value of the parameter projection


if (projection == "L"){ ## Project on L
  message("Performing eigen-decomposition of L...")
  eigen_L = eigen(L_ret)
  
}else{ ## Project on LoM
  
  ### Construct the recombination map matrix (NRF)
  # Diagonal elements are 1
  # Off-diagonal elements are non-recombinant fractions
  
  # Construct the  non-recombination fraction matrix
  # Calculating distances between sites, multiply by the recombination rate
  # Subtract from 1
  
  message("Calculating the the matrix of non-recombinant fractions for the starting population...")
  
  dist = matrix(0, nrow(L_ret), nrow(L_ret)) # Matrix of paired distances
  
  # Loop through columns 
  
  for (site in 1:nrow(L_ret)){
    dist[, site] = abs(mutations_ret$Position - mutations_ret$Position[site])
    #rf = 0.5*(1 - exp(-2*dist*r_expt))
    #NRF[, site] =  1 - rf
  }
  
  NRF = 1 - 0.5*(1 - exp(-2*dist*r_expt))
  
  # Calculate the covariance structure for del_P under drift and recombibation 
  # var(del_P) = L/2N*SUM(1 to n_gen){(NRF^(n+1)(1 - 1/2N)^n)}
  
  LoM = matrix(0, nrow(L_ret), nrow(L_ret))
  
  for (n in 1:(ngen_expt)){
    LoM = LoM + (1/(n_ind_exp))*L_ret*(NRF^(1+n))*(1 - 1/(2*n_ind_exp))^n
    #LoM = LoM + L_ret*(NRF^(1+n))*(1 - 1/(2*n_ind_exp))^n
    #LoR = LoR + L*(NRF^(1+n))*(1 - 1/(2*pop_size))^n
  }
  
  # Eigen-decomposition of LoM
  
  message("Performing eigen-decomposition of LoM...")
  
  eigen_L = eigen(LoM)
  
}

### Eigen decomposition is expressed in our theory as LoR = U%*%D^2%*%t(U)
# U is the matrix of eigenvecors
# D is a diagonal matrix of the square roots of the eigenvalues
# Retain only those eigen values (and corresponding eigen vectors) greater than tol

tol  = max(sqrt(.Machine$double.eps), eigen_L$values[order(eigen_L$values, decreasing = T)][n_ind_exp + 1])

eigen_ret = which(eigen_L$values>tol) 

U = eigen_L$vectors
U = U[, eigen_ret]
D = diag(sqrt(eigen_L$values[eigen_ret]))
inv_D = diag(1/(diag(D)))


### Calculate vA and va 

message("Computing the actual Va for the starting population...")



list_alpha = mutations_ret$s

vA = t(list_alpha)%*%L_ret%*%list_alpha  # Additive genetic variance
va = sum(diag(L_ret)*list_alpha*list_alpha) # Additive genic variance



#######################################################################################
#######################################################################################
################################## Experiment #########################################
#######################################################################################
#######################################################################################

message("Forward simulating the experiment using SLiM...")

# Create empty vector to create the data frame containing the following variables as columns:
# 1. Raw delta P
# 2. Projected delta P
# 3. Cage ID (replicate)
# 4. Locus ID

d_proj = c()
d_raw = c()

### Loop over the cage replicates

for (cage in (1:n_cages)){
  
  message(paste("Cage", cage, "in progress..."))
  
  #######################
  ###### run SLiM #######
  #######################   
    
  # SLiM by default generates random seeds in a very odd way (based on the clock and process ID)
  # Generate a random seed for SLiM
  
  #slim_seed = sample(1:100000, 1)
  
  
  
  ### This has lot's of command line arguments. Creating separate strings for each argument
  
  expt_arg1 = paste("-d mu=", mu_expt, sep = "")
  expt_arg2 = paste("-d shape=", shape, sep = "")
  expt_arg3 = paste("-d scale=", scale, sep = "")
  expt_arg4 = paste("-d sequence_length=", sequence_length, sep = "")
  expt_arg5 = paste("-d r=", r_expt, sep = "")
  
  #arg6 = paste("-d msprime_output_path=","'", msprime_output_path, "'", sep = "") # Only works on Windows
  
  expt_arg6 = paste("-d ", shQuote(paste("slim_output_path=","'", slim_output_path, "'", sep = "")), sep = "") 
  expt_arg7 = paste("-d mut_ratio=", mut_ratio, sep = "")
  
  
  system(paste("slim", expt_arg1, expt_arg2, expt_arg3, expt_arg4, expt_arg5, expt_arg6, expt_arg7, slim_expt_path))
  
  
  ###############################
  ###### extract mutations ######
  ###############################
  
  # There are three command line arguments (1. Path of the SLiM output file, 2. Path where mutations are to be written, 3. gen) 
  
  
  message("Extracting mutations...")
  
  for (gen in (end_gen + 1):(end_gen + 4)){
    message(paste((gen-end_gen)*100/5, "% extracted..."))
    system(paste("python", extract_mut_path, paste(slim_output_path, "/Output_experiment_", as.integer(gen), ".txt", sep = ""), mutations_path, as.integer(gen))) # as.integer done to avoid scientific notation
  }
  
  

  
  ### Create an empty matrix to store allelic frequencies in each generation
  
  # If some of the loci get fixed/lost in subsequent generations, NAs should be inserted
  
  message("Calculating allele frequency change...")
  
  # Create an empty vector to store allele frequencies
  
  P = c()
  
  
  # store the frequencies in the parent's generation in P
  # Frequency = (Number of genomes)/(2*popsize)
  
  P = cbind(P, mutations_ret$Number/(2*n_ind))
  
  
  
  ### Loop through the generations of the experiment identifying mutations that were present in the parents' generation (using permanent IDs) and recording their frequencies
  
  for (gen in (end_gen+1):(end_gen+ngen_expt+1)){
    # Read the file storing mutation information
    mut = read.csv(paste(mutations_path ,"/Mutations_", as.integer(gen), ".txt", sep = ""), sep = " ") # as.integer gets rid of scientific notation
    
    # Sort mutations based on the Temp_ID, so that the order of loci matches the order in the C and L matrices
    
    mut = mut[order(mut$Temp_ID),]
    
    # Create an empty vector to store frequencies of mutations in the current generation
    freq = c()
    
    # Loop through the permanent IDs of  mutations segregating in end_gen (parents' generation)
    # i.e. Loop through Permanent IDs in mutations_1
    # Check if each mutation is present in the current generation
    # If present, record the frequency in freq, otherwise add either 0 or 1 to freq using the round() function
    
    for(mutation in mutations_ret$Permanent_ID){
      if(mutation %in% mut$Permanent_ID){freq = rbind(freq, (mut[which(mut$Permanent_ID==mutation),]$Number)/(2*n_ind_exp))}
      else {
        freq = rbind(freq, round(P[which(mutations_ret$Permanent_ID==mutation), gen - end_gen]))
        #print(round(P[which(mutations_1$Permanent_ID==mutation), gen -1]))
      }
    }
    
    # Add the vector freq to P
    
    P = cbind(P, freq)
    #print(paste(round((gen-start_gen)*100/(end_gen-start_gen), 2), " % complete!"))
    
  }
  #print("!!!!!!!!!!!!!!!!!!!! TEST !!!!!!!!!!!!!!!")
  #print(P[3,3])
  #print("!!!!!!!!!!!!!!!!!!!! TEST !!!!!!!!!!!!!!!")
  # Calculate the vector of allele frequency changes over three generations of the experiment
  
  del_P_current = P[,ngen_expt + 2] - P[,2]
  
  del_P_current[is.na(del_P_current)]<-0
  
  
  
  
  # Calculate projected allele frequency change in the new basis defined by the eigen decomposition of LoR
  
  message("Calculating projected allele frequency change...")
  
  del_P_proj_current = inv_D%*%t(U)%*%del_P_current # inv_D = diag(1/(diag(D))). The fuction inv(D) would not work. Removing inv_D%*%
  
  d_proj = rbind(d_proj, cbind(del_P_proj_current, cage, 1:length(del_P_proj_current)))
  d_raw = rbind(d_raw, cbind(del_P_current, cage, 1:length(del_P_current)))
  
}

################################
######### Fit models ###########
################################

message("Fitting models...")
 
# Create a data frame

d_proj = data.frame("del_P_proj" = d_proj[,1], "Cage" = d_proj[,2], "Locus" = d_proj[,3])
d_raw = data.frame("del_P" = d_raw[,1], "Cage" = d_raw[,2], "Locus" = d_raw[,3])

# Calculate the covariance structure of locus effects

############## Function for raising a matrix to some power #############
# ONLY FOR NON-NEGATIVE POWERS

matrix_power = function(M, k){
  K = diag(nrow(M))
  i = 0
  while(i<k){
    K = K%*%M
    i = i + 1
  }
  
  return(K)
}



if(projection == "L"){
  SC = D*D
}else{
  SC = inv_D%*%t(U)%*%matrix_power(L_ret, p_alpha + 2)%*%U%*%inv_D
}

invSC = solve(SC) # Calculate inverse

invSC<-as(invSC, "sparseMatrix")
attr(invSC, "INVERSE")<-TRUE
attr(SC, "INVERSE")<-F
attr(invSC,"rowNames")<-as.character(eigen_ret) # Used for sparse-form matrices
attr(invSC,"colNames")<-as.character(eigen_ret) # Used for sparse-form matrices
dimnames(invSC) <- list(eigen_ret,eigen_ret)  # used for full-form matrices
dimnames(SC) <- list(eigen_ret,eigen_ret)  # used for full-form matrices

# Convert Locus to a factor

d_proj$Locus = factor(d_proj$Locus)

message("Fitting model...")



if (method == "REML"){
  
  m1<-asreml(del_P_proj~1, random = ~vm(Locus, SC), data=d_proj)
  vA_est = summary(m1)$varcomp[1,1]*sum(diag(L_ret)^(p_alpha + 1))/(ngen_expt)^2
  
}else{

  prior = list(R = list(V = 1, nu = 0), G = list(G1 = list(V = 1, nu = 1, alpha.mu=0, alpha.V=1000)))
  fit_mcmc = MCMCglmm(del_P_proj ~ 1, random = ~ Locus, ginverse=list(Locus=invSC), family="gaussian", prior = prior, data = d_proj, pr = T) 
  vA_est = mean(fit_mcmc$VCV[1])*sum(diag(L_ret)^(p_alpha + 1))/(ngen_expt)^2
  
}

### Save image

#save.image(file = paste(output_path, "/test1.RData", sep = ""))

